[
    {
        "file_path": "sql\\views.py",
        "scope": "index",
        "lineno": 51,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which typically represents an HTTP request. However, in this specific function, the `request` object is not directly used to determine the output.\n\nMain Functionality:  \n- The function's core purpose is to redirect a user to a specific URL path. It retrieves a configuration setting named \"index_path_url\" using the `SysConfig` class. If the setting is not found, it defaults to \"sqlworkflow\". The function then constructs a URL by appending the stripped value of \"index_path_url\" to a base path and returns a redirect response to that URL.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponseRedirect` object, which is a type of HTTP response that instructs the client to redirect to a different URL. The URL is dynamically constructed based on the configuration setting."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "login",
        "lineno": 56,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which is typically provided by the user through an HTTP request. This request object can contain various attributes such as user authentication status, cookies, and other HTTP request data.\n\nMain Functionality:  \n- The function's core purpose is to manage the login page logic. It first checks if the user is already authenticated. If the user is authenticated, it redirects them to the homepage (\"/\"). If the user is not authenticated, it renders the \"login.html\" template. The function also populates the context with configuration settings that determine if certain authentication methods (like OIDC, DingDing, CAS) are enabled, as well as the display name for the OIDC login button.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponseRedirect` object if the user is authenticated, redirecting them to the homepage.  \n- If the user is not authenticated, it returns an `HttpResponse` object that renders the \"login.html\" template with the specified context, which includes various settings and configurations for the login page."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "twofa",
        "lineno": 74,
        "summarize": "User Input Sources:  \n- The function takes input from the `request` object, which is typical in web applications. This can include data from HTTP request parameters, session data, and user authentication status.\n\nMain Functionality:  \n- The function is designed to handle a two-factor authentication (2FA) page. It first checks if the user is authenticated; if so, it redirects them to the home page. If not, it retrieves the username from the session data and checks if there are any 2FA methods configured for that user. It constructs a list of available authentication types (e.g., TOTP, SMS) and prepares additional context information such as the phone number associated with SMS authentication. If no username is found in the session, it redirects the user to the login page.\n\nOutputs / Return Values:  \n- The function returns an HTTP response. If the user is authenticated, it redirects to the home page. If not authenticated and no username is found in the session, it redirects to the login page. Otherwise, it renders an HTML page (\"2fa.html\") with context data, including the verification mode, available authentication types, username, and phone number."
    },
    {
        "file_path": "common\\auth.py",
        "scope": "sign_out",
        "lineno": 208,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which could originate from an HTTP request. This includes user session data and potentially other user-related information.\n\nMain Functionality:  \n- The function's core purpose is to log a user out of the current session. It first retrieves the user from the request object and then calls a logout function to terminate the user's session. After logging out, it checks if the user has a DingTalk user ID and if DingTalk authentication is enabled. If both conditions are met, it redirects the user to the DingTalk logout page. Otherwise, it redirects the user to a login page within the application.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponseRedirect` object. This object redirects the user to a URL, which could either be the DingTalk logout page or the application's login page, depending on the conditions evaluated within the function."
    },
    {
        "file_path": "common\\auth.py",
        "scope": "sign_up",
        "lineno": 165,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request, specifically from the POST parameters. The user-provided data includes `username`, `password`, `password2`, `display`, and `email`.\n\nMain Functionality:  \nThe core purpose of this function is to handle user sign-up requests. It first checks if the sign-up feature is enabled by retrieving a configuration setting (`sign_up_enabled`). If sign-up is not enabled, it returns a JSON response indicating this. If sign-up is enabled, it performs several checks on the user input: ensuring that both `username` and `password` are provided, checking that the username is not already taken, verifying that the two password fields match, and ensuring that a display name is provided. If any of these checks fail, an appropriate error message is returned. If all checks pass, it attempts to validate the password and create a new user account in the database. If password validation fails, it returns an error message; otherwise, it confirms successful sign-up.\n\nOutputs / Return Values:  \nThe function returns an `HttpResponse` object containing a JSON-formatted response. The response includes a `status` code (0 for success, 1 for failure), a `msg` with a message describing the outcome, and `data`, which is `None` in all cases."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqlworkflow",
        "lineno": 121,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which is typical in web applications using frameworks like Django. This `request` object could contain user-related information, such as the logged-in user's details and potentially other HTTP request parameters.\n\nMain Functionality:  \nThe primary purpose of the `sqlworkflow` function is to render a webpage that lists SQL workflow orders. The function determines which SQL orders the user is allowed to view based on their permissions. If the user is a superuser or has specific permissions, they can view all orders. Users with certain review or execution permissions can view orders within their resource groups. All other users can only view orders they submitted. The function filters the SQL workflow orders based on these criteria and retrieves associated instances and resource groups for display.\n\nOutputs / Return Values:  \nThe function returns an HTML page rendered with the `sqlworkflow.html` template. The context passed to the template includes a list of status choices (`status_list`), filtered `instance` objects, and `resource_group` objects that the user is allowed to view."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "submit_sql",
        "lineno": 210,
        "summarize": "User Input Sources:  \nThe function `submit_sql` takes input from an HTTP request object, specifically through the `request` parameter. This request object could contain user-related data, such as authentication details, session information, and other HTTP request parameters.\n\nMain Functionality:  \nThe main purpose of the `submit_sql` function is to render a web page for submitting SQL queries. It first retrieves the current user from the request object and gathers a list of groups the user belongs to. It then accesses system configurations via the `SysConfig` class. Additionally, it ensures that a specific tag (\"can_write\") exists in the `InstanceTag` model, creating it if necessary. Finally, it prepares a context dictionary with the user's group list, a configuration setting for enabling backup, and a map of available database engines.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the \"sqlsubmit.html\" template, populated with the context data, which includes user group information, configuration settings, and available database engines."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "detail",
        "lineno": 232,
        "summarize": "User Input Sources:  \n- The function takes input from the `request` object, which typically contains HTTP request data, including user session information and potentially user-submitted data.\n- It also takes `workflow_id` as a parameter, which could be derived from the URL or a form submission.\n\nMain Functionality:  \n- The function is designed to display the detailed page for a specific SQL workflow. It retrieves the workflow details using the `workflow_id`.\n- It checks if the current user has permission to view the workflow details. If not, it raises a `PermissionDenied` exception.\n- If the workflow status is not \"workflow_autoreviewwrong\", it evaluates several permissions related to reviewing, executing, timing tasks, canceling, and rolling back the workflow.\n- It attempts to fetch audit logs for the workflow and the last operation information.\n- If the workflow status is \"workflow_timingtask\", it retrieves information about the scheduled task's next run date.\n- The function also gathers information about the current reviewers from the workflow's review nodes.\n- Finally, it checks if manual execution confirmation is enabled from the system configuration.\n\nOutputs / Return Values:  \n- The function renders an HTML page (\"detail.html\") with a context dictionary that includes workflow details, current reviewers, last operation information, various permission flags, review information, whether manual execution confirmation is enabled, and the run date for scheduled tasks."
    },
    {
        "file_path": "sql\\offlinedownload.py",
        "scope": "offline_file_download",
        "lineno": 367,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, specifically from the GET parameters `file_name` and `workflow_id`. These parameters are likely provided by the user through the URL query string.\n\nMain Functionality:  \n- The function is designed to handle file download requests. It supports both local/SFTP storage and cloud object storage (such as S3 or Azure). The function first checks if the requested file exists in the storage system. If the file is found and the storage type is either SFTP or local, it returns the file as a direct file stream. If the storage type is cloud-based (S3 or Azure), it generates a presigned URL for temporary access to the file and returns it. If any errors occur during these processes, the function logs the error and returns an appropriate JSON error response. Additionally, it logs an audit entry for the download attempt unless the HTTP method is \"HEAD\".\n\nOutputs / Return Values:  \n- The function returns different types of HTTP responses:\n  - A JSON response with an error message and a 404 status code if the file does not exist.\n  - A file response containing the file stream if the storage type is SFTP or local.\n  - A JSON response with a redirect type and a presigned URL for cloud storage types (S3 or Azure).\n  - A JSON response with an error message and a 500 status code if any exception occurs during processing."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "passed",
        "lineno": 237,
        "summarize": "User Input Sources:  \n- The function takes user input from an HTTP request via `request.POST`. Specifically, it retrieves `workflow_id` and `audit_remark` from the POST data. These values can originate from user-submitted form data in a web application context.\n\nMain Functionality:  \n- The function is designed to handle the approval process for an SQL workflow review. It begins by extracting the `workflow_id` and `audit_remark` from the POST request. If `workflow_id` is missing or invalid, it returns an error page.\n- It then attempts to retrieve the corresponding `SqlWorkflow` object from the database. If the object does not exist, it returns an error page.\n- The function then initializes a system configuration object and an auditor for the workflow. Within a database transaction, it attempts to perform an audit operation to pass the workflow. If an exception occurs during this process, it returns an error page with the exception message.\n- If the audit is successfully completed and the workflow status is marked as passed, it updates the workflow status to \"workflow_review_pass\" and saves the changes.\n- If notifications are enabled for the \"Pass\" phase, it schedules an asynchronous task to send a notification about the audit's success.\n\nOutputs / Return Values:  \n- On error conditions (missing `workflow_id`, nonexistent workflow, audit failure), it returns an HTML error page rendered with an error message.\n- On successful execution, it redirects the user to a detailed view of the SQL workflow using `HttpResponseRedirect`, providing the `workflow_id` as an argument to the URL."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "execute",
        "lineno": 288,
        "summarize": "User Input Sources:  \n- The function takes input from the `request` object, which could originate from an HTTP request. Specifically, it uses `request.POST.get(\"workflow_id\", 0)` to retrieve the `workflow_id`, and `request.POST.get(\"mode\")` to retrieve the `mode`. Additionally, it checks user permissions through `request.user.has_perm(...)`.\n\nMain Functionality:  \n- The function is designed to execute a SQL workflow based on the provided `workflow_id` and `mode`. It first checks if the user has the necessary permissions to execute SQL. If the `workflow_id` is not provided or invalid, it returns an error. It also checks if the user is allowed to execute the workflow and if the execution is within an allowed time period. Depending on the `mode`, it either queues the workflow for automatic execution or marks it as manually executed. It logs the actions taken and, if configured, sends notifications after execution.\n\nOutputs / Return Values:  \n- The function returns an HTML error page if there are issues with the `workflow_id`, permissions, or execution time. If execution proceeds without errors, it redirects the user to the SQL workflow detail page using `HttpResponseRedirect`."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "timing_task",
        "lineno": 377,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object named `request`.\n- It specifically uses `request.POST.get(\"workflow_id\")` and `request.POST.get(\"run_date\")` to retrieve user-provided data from POST parameters.\n\nMain Functionality:  \n- The function is designed to schedule an SQL execution task for a specified future date and time.\n- It first checks if the user has the necessary permissions to execute SQL tasks.\n- It retrieves the `workflow_id` and `run_date` from the request and performs validation checks to ensure they are not empty and that the `run_date` is not in the past.\n- It fetches the SQL workflow details using the `workflow_id`.\n- It checks if the user is authorized to schedule the task using the `can_timingtask` function.\n- It converts the `run_date` into a `datetime` object and checks if it falls within a permissible execution time window using the `on_correct_time_period` function.\n- If all checks pass, it updates the workflow status to indicate it is scheduled for execution, adds a scheduled task using `add_sql_schedule`, and logs this operation in an audit trail.\n- The function employs a transaction to ensure data consistency during the status update and task scheduling.\n\nOutputs / Return Values:  \n- If any validation or permission check fails, the function returns an HTML error page rendered with a specific error message.\n- If an exception occurs during the transaction, it logs the error and returns an HTML error page with the exception message.\n- Upon successful scheduling, it redirects the user to the SQL workflow detail page using `HttpResponseRedirect`."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "alter_run_date",
        "lineno": 204,
        "summarize": "User Input Sources:  \nThe function `alter_run_date` takes input from an HTTP request object, specifically using POST parameters. It retrieves the following user-provided inputs:\n- `workflow_id`: Retrieved from `request.POST.get(\"workflow_id\", 0)`.\n- `run_date_start`: Retrieved from `request.POST.get(\"run_date_start\")`.\n- `run_date_end`: Retrieved from `request.POST.get(\"run_date_end\")`.\n\nMain Functionality:  \nThe core purpose of the function `alter_run_date` is to allow an authorized user to modify the execution time window of a specified workflow. The function first checks if the `workflow_id` is valid (not zero) and then verifies if the current user has permission to review the workflow using the `Audit.can_review` method. If the user has the necessary permissions, the function updates the execution start and end dates in the database for the specified workflow using the `SqlWorkflow` model. If any errors occur during the database operation, it returns an error message.\n\nOutputs / Return Values:  \nThe function produces different outputs based on the execution flow:\n- If the `workflow_id` is zero or the user does not have the necessary permissions, it renders an error HTML page with an appropriate error message.\n- If the database update operation fails, it also renders an error HTML page with the exception message.\n- Upon successful completion, it redirects the user to the detail page of the specified workflow using an HTTP redirect."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "cancel",
        "lineno": 440,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request object, specifically using `request.POST` to retrieve the parameters \"workflow_id\" and \"cancel_remark\". These parameters can originate from user input in a web form or API request.\n\nMain Functionality:  \nThe core purpose of the function is to cancel a workflow process identified by the \"workflow_id\". It first checks if the \"workflow_id\" and \"cancel_remark\" are provided; if not, it returns an error message. It verifies whether the user has permission to cancel the workflow. Depending on the user's role, it determines the appropriate action (abort or reject). The function then updates the workflow status to \"workflow_abort\" within a database transaction to ensure consistency. If the workflow was scheduled for timed execution, it deletes the scheduled task. It also handles notifications for the cancellation phase if configured to do so.\n\nOutputs / Return Values:  \nThe function returns an HTTP response. If there are errors, it returns an HTML error page with a specific error message. If the cancellation is successful, it redirects the user to a detail page of the workflow using `HttpResponseRedirect`."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "rollback",
        "lineno": 314,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP request object, specifically from the `GET` parameters. The parameters are `workflow_id` and `download`. Additionally, it uses the `request.user` to check permissions.\n\nMain Functionality:  \nThe primary purpose of the function is to handle the rollback process for a SQL workflow. It checks if the user has permission to perform a rollback on the specified workflow. If the `download` parameter is present, it generates a SQL file containing rollback statements for the workflow and prepares it for download. If `download` is not specified, it prepares data to be rendered on a webpage showing rollback details.\n\nOutputs / Return Values:  \n- If the `download` parameter is present and the process is successful, it returns a file response containing the rollback SQL file for download.\n- If the `download` parameter is absent, it returns an HTML page displaying the rollback details.\n- If there are errors (e.g., missing `workflow_id`, permission denied, or exceptions during SQL retrieval), it returns an error HTML page with an appropriate error message."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqlanalyze",
        "lineno": 362,
        "summarize": "User Input Sources:  \nThe function `sqlanalyze` takes an input parameter named `request`, which is an HTTP request object. This object can contain data originating from the user, such as HTTP headers, cookies, GET and POST parameters, and other request-related information.\n\nMain Functionality:  \nThe core purpose of the `sqlanalyze` function is to render a web page for SQL analysis. It is decorated with `@permission_required(\"sql.menu_sqlanalyze\", raise_exception=True)`, which enforces that the user must have the specific permission \"sql.menu_sqlanalyze\" to access this function. If the user does not have the required permission, an exception is raised, preventing unauthorized access.\n\nOutputs / Return Values:  \nThe function returns an HTTP response generated by the `render` function. This response contains the content of the \"sqlanalyze.html\" template, which is presumably an HTML page for SQL analysis."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqlquery",
        "lineno": 368,
        "summarize": "User Input Sources:  \n- The function takes `request` as an input parameter, which is an HTTP request object. This object can contain user-related data such as the authenticated user (`request.user`).\n\nMain Functionality:  \n- The function `sqlquery` is designed to render an online SQL query page. It starts by ensuring a specific tag (\"can_read\") is present in the `InstanceTag` model, creating it if it doesn't exist. It then gathers user-specific information such as user groups, favorite queries, and permissions related to downloading query results. This data is compiled into a context dictionary that is used to render an HTML page.\n\nOutputs / Return Values:  \n- The function returns an HTTP response that renders the \"sqlquery.html\" template. The rendered page includes user-specific data such as favorite SQL queries, permission flags for downloading, and other context information necessary for displaying the SQL query interface."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "slowquery",
        "lineno": 468,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which typically originates from an HTTP request. This means it could contain user input such as HTTP request parameters, cookies, and other request data.\n\nMain Functionality:  \nThe function `slowquery` is a Django view that serves a specific webpage. It is decorated with `@permission_required(\"sql.menu_slowquery\", raise_exception=True)`, which checks if the user associated with the request has the required permission (`sql.menu_slowquery`). If the user lacks this permission, an exception is raised. If the permission check is successful, the function renders a webpage.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the \"slowquery.html\" template. This is typically an HTML page that is sent back to the user's web browser for display."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqladvisor",
        "lineno": 462,
        "summarize": "User Input Sources:  \nThe function `sqladvisor` takes a single parameter, `request`, which is typically an HTTP request object in a Django web application. This object can contain user input from HTTP request parameters, such as GET or POST data, cookies, and other request metadata.\n\nMain Functionality:  \nThe core purpose of the `sqladvisor` function is to render a web page related to an SQL optimization tool. The function is decorated with `@permission_required(\"sql.menu_sqladvisor\", raise_exception=True)`, which ensures that only users with the specified permission (\"sql.menu_sqladvisor\") can access the page. If a user lacks this permission, an exception is raised, preventing access to the page.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the \"sqladvisor.html\" template. This output is an HTML page that is served to the user, allowing them to interact with the SQL optimization tool's interface."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "queryapplylist",
        "lineno": 396,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which is typical in Django applications. This `request` object may contain user-related data such as authentication information, session data, and potentially query parameters from an HTTP request.\n\nMain Functionality:  \n- The function `queryapplylist` is a Django view function that serves a web page for viewing a list of permission applications. It first retrieves the current user from the request object. Then, it calls the `user_groups` function to obtain a list of resource groups associated with the user. Finally, it prepares a context dictionary containing the group list and an `engine_map`, and renders an HTML page called \"queryapplylist.html\" with this context.\n\nOutputs / Return Values:  \n- The function returns an HTTP response that renders an HTML page (\"queryapplylist.html\") with a context containing the user's group list and a mapping of engines (`engine_map`)."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "queryapplydetail",
        "lineno": 406,
        "summarize": "User Input Sources:  \n- The function takes two inputs that could originate from the user:\n  1. `request`: This is typically an HTTP request object, which may include user-specific data such as user credentials, session information, and other request parameters.\n  2. `apply_id`: This is likely obtained from the URL or request parameters, identifying a specific application or workflow that the user is interested in.\n\nMain Functionality:  \n- The primary purpose of the function is to retrieve and display the details of a specific privilege application. It does this by:\n  1. Fetching the application details using the `apply_id`.\n  2. Creating an audit handler to get review information related to the application.\n  3. Determining whether the current user can review the application.\n  4. Retrieving the latest audit log information if the application is in a specific status.\n  5. Identifying the current reviewers for the application based on the review information and user group membership.\n  6. Compiling all this information into a context dictionary for rendering.\n\nOutputs / Return Values:  \n- The function returns an HTML page rendered with the context data. This page, \"queryapplydetail.html\", displays the details of the application, including workflow details, current reviewers, review information, last operation information, and whether the user can review the application."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "queryuserprivileges",
        "lineno": 451,
        "summarize": "User Input Sources:  \n- The function takes `request` as a parameter, which is likely an HTTP request object. This means it could potentially include user-originated data such as query parameters, cookies, or other HTTP headers.\n\nMain Functionality:  \n- The function queries a database model `QueryPrivileges` to retrieve a list of distinct users whose records are not marked as deleted (`is_deleted=0`). It collects these users' display names into a list and prepares a context dictionary with this list. The purpose of the function is to render a web page that displays user privilege information, using the \"queryuserprivileges.html\" template.\n\nOutputs / Return Values:  \n- The function returns an HTTP response generated by rendering the \"queryuserprivileges.html\" template with the context that includes the list of user display names. This results in an HTML page being sent to the client."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "dbdiagnostic",
        "lineno": 497,
        "summarize": "User Input Sources:  \nThe function `dbdiagnostic` takes a single parameter, `request`, which is likely an HTTP request object. This object can contain user input in the form of query parameters, form data, cookies, and headers.\n\nMain Functionality:  \nThe core purpose of the `dbdiagnostic` function is to render a web page for session management. It is decorated with `@permission_required(\"sql.menu_dbdiagnostic\", raise_exception=True)`, which means that the function checks if the user has the necessary permission, `\"sql.menu_dbdiagnostic\"`, to access this functionality. If the user does not have this permission, an exception is raised, preventing access to the page.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the HTML template \"dbdiagnostic.html\". This response is intended to be displayed as a web page to the user in a browser."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "workflows",
        "lineno": 637,
        "summarize": "User Input Sources:  \nThe function `workflows` takes a parameter `request`, which is typically an HTTP request object in web frameworks like Django. This object can contain user input from various sources, such as query parameters, form data, cookies, and headers.\n\nMain Functionality:  \nThe core purpose of the `workflows` function is to render a webpage. It uses the `render` function to generate an HTML response using a template named \"workflow.html\". This suggests that the function is intended to display a \"\u5f85\u529e\u5217\u8868\u9875\u9762\" (translated as \"to-do list page\") to the user.\n\nOutputs / Return Values:  \nThe function returns an HTTP response object that contains the rendered HTML content of the \"workflow.html\" template. This HTML page is what is sent back to the user's browser for display."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "workflowsdetail",
        "lineno": 642,
        "summarize": "User Input Sources:  \nThe function takes two inputs:\n1. `request`: This is likely an HTTP request object, which can contain user input through query parameters, POST data, headers, etc.\n2. `audit_id`: This parameter is likely derived from user input, such as a URL parameter or form data, and is used to retrieve specific audit details.\n\nMain Functionality:  \nThe primary purpose of the function is to provide details for a specific workflow based on its type. It retrieves audit details using the `audit_id` and checks the `workflow_type` of the audit. Depending on the `workflow_type`, it redirects the user to a specific URL related to the workflow:\n- If the workflow type is `QUERY`, it redirects to a query application detail page.\n- If the workflow type is `SQL_REVIEW`, it redirects to an SQL review detail page.\n- If the workflow type is `ARCHIVE`, it redirects to an archive detail page.\nIf the audit detail does not exist, it raises an `Http404` error indicating that the record does not exist.\n\nOutputs / Return Values:  \nThe function returns an HTTP response, specifically a redirection to different URLs based on the workflow type. If the audit detail does not exist, it raises an `Http404` exception, which results in an HTTP 404 error page being displayed."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "dbaprinciples",
        "lineno": 663,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which is typical in a web application context. This `request` object can contain data originating from the user, such as HTTP request parameters, cookies, or session data.\n\nMain Functionality:  \nThe function `dbaprinciples` is designed to render a web page that displays the content of a Markdown file. It reads the content of a file named `docs.md` located in a `docs` directory within the base directory of the project. The function reads this file, replaces newline characters with the string `\\\\n`, and then passes the modified content as context to render an HTML template named `dbaprinciples.html`.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders an HTML page. This page is generated using the `dbaprinciples.html` template and includes the content of the Markdown file as part of its context."
    },
    {
        "file_path": "common\\dashboard.py",
        "scope": "pyecharts",
        "lineno": 21,
        "summarize": "User Input Sources:  \nThe function `pyecharts` takes a `request` parameter, which is an HTTP request object. This object could contain user input through various means such as URL parameters, form data, or cookies.\n\nMain Functionality:  \nThe core purpose of the `pyecharts` function is to generate and display statistical data and charts on a dashboard. It collects various counts related to SQL workflows, query privileges, active users, and instances from the database. It also retrieves and processes data to create visual charts, specifically a pie chart and a stacked bar chart, using methods from a `ChartDao` object. These charts are then embedded into a web page template.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the \"dashboard.html\" template. This response includes embedded chart data and statistical counts. The charts are represented as HTML content suitable for embedding in a webpage, and the statistical data is likely included as part of the template context."
    },
    {
        "file_path": "common\\dashboard.py",
        "scope": "DashboardApi",
        "lineno": 61,
        "summarize": "User Input Sources:  \nThe function takes input from HTTP request parameters. Specifically, it retrieves the values of \"start_date\" and \"end_date\" from the query parameters of the incoming HTTP GET request.\n\nMain Functionality:  \nThe function's core purpose is to handle an HTTP request to generate dashboard data within a specified date range. It validates the date strings received from the request, and if they are valid, it retrieves chart data for the specified date range. If the date validation fails, it returns an error response.\n\nOutputs / Return Values:  \nThe function returns a JSON response. If the date validation is successful, it includes the chart data in the response. If there is a validation error, it returns a JSON object with an error message and a 400 HTTP status code."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "group",
        "lineno": 625,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which is typically associated with HTTP requests in web frameworks like Django. This object can contain user-generated data such as query parameters, form data, cookies, and headers.\n\nMain Functionality:  \nThe function `group` is designed to handle web requests for a resource group management page. It is decorated with `@superuser_required`, indicating that the function is restricted to users with superuser privileges. This decorator likely checks the user's permissions before allowing access to the function.\n\nOutputs / Return Values:  \nThe function returns an HTTP response generated by rendering the \"group.html\" template. This response is typically an HTML page that is sent back to the user's web browser, displaying the content defined in the \"group.html\" template."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "groupmgmt",
        "lineno": 631,
        "summarize": "User Input Sources:  \nThe function `groupmgmt` takes two inputs: `request` and `group_id`. The `request` object is typically provided by the Django framework when handling an HTTP request, and it can contain user input from various sources, such as URL parameters, form data, or cookies. The `group_id` is likely derived from the URL or another part of the HTTP request, making it a user-controlled input.\n\nMain Functionality:  \nThe primary purpose of the `groupmgmt` function is to handle the display of a resource group management page. It retrieves a specific `ResourceGroup` object from the database using the provided `group_id`. This function is decorated with `@superuser_required`, indicating that it is restricted to users with superuser privileges, adding a layer of security by ensuring only authorized users can access this functionality.\n\nOutputs / Return Values:  \nThe function returns an HTTP response generated by the `render` function. This response is an HTML page (`groupmgmt.html`) that includes data about the specified resource group, passed in the context as `{\"group\": group}`. This output is intended for rendering in a web browser."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "instance",
        "lineno": 474,
        "summarize": "User Input Sources:  \n- The function takes an `HttpRequest` object as its input parameter, which can include user-originated data such as HTTP request parameters, headers, and cookies.\n\nMain Functionality:  \n- The function is a Django view named `instance` that is protected by a permission requirement decorator `@permission_required(\"sql.menu_instance\", raise_exception=True)`. This decorator checks if the user has the necessary permissions to access the view, raising an exception if they do not. The core purpose of the function is to manage and render an instance management page. It retrieves active instance tags from the `InstanceTag` model, which are presumably used for categorizing or organizing instances, and then renders these tags along with an `engine_map` to the \"instance.html\" template.\n\nOutputs / Return Values:  \n- The function returns an HTTP response generated by rendering the \"instance.html\" template. The context provided to the template includes a dictionary with \"tags\" (active instance tags) and \"engines\" (presumably the `engine_map`, although its contents are not specified in the given code)."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "instanceaccount",
        "lineno": 482,
        "summarize": "User Input Sources:  \nThe function `instanceaccount` takes a `request` object as its input, which is typically derived from an HTTP request made by a user. This means it can include user-originated data such as query parameters, form data, cookies, and headers.\n\nMain Functionality:  \nThe primary purpose of the `instanceaccount` function is to render a web page for instance account management. It is decorated with a `@permission_required` decorator that checks if the user has the necessary permission (`sql.menu_instance_account`) to access this view. If the user lacks this permission, an exception is raised, likely resulting in an HTTP 403 Forbidden response.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the `instanceaccount.html` template. This is an HTML page intended for managing instance accounts."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "database",
        "lineno": 488,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which is typically an HTTP request object. This could contain user-originated data such as HTTP request parameters, headers, and cookies.\n\nMain Functionality:  \n- The function `database` is a Django view that is protected by a permission requirement (`permission_required(\"sql.menu_database\", raise_exception=True)`). This means that only users with the specified permission can access this view. The core purpose of the function is to retrieve a list of all active users from the `Users` database table (where `is_active` is set to 1) and render a template named `database.html`. The active users are passed to the template as a context variable named `active_user`.\n\nOutputs / Return Values:  \n- The function returns an HTTP response that renders the `database.html` template. The context for the template includes the list of active users, which can be used within the template to display user information."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "instance_param",
        "lineno": 509,
        "summarize": "User Input Sources:  \nThe function `instance_param` takes a single parameter `request`, which is an HTTP request object. This object typically contains data that can originate from the user, such as query parameters, form data, and cookies.\n\nMain Functionality:  \nThe core purpose of the `instance_param` function is to serve a web page related to instance parameter management. It is protected by a decorator `@permission_required(\"sql.menu_param\", raise_exception=True)`, which ensures that the user has the necessary permissions (`sql.menu_param`) to access this page. If the user does not have the required permissions, an exception will be raised, preventing access to the page.\n\nOutputs / Return Values:  \nThe function returns an HTTP response object generated by the `render` function. This response contains the rendered HTML content of the \"param.html\" template, which is intended to be displayed in a web browser."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "my2sql",
        "lineno": 515,
        "summarize": "User Input Sources:  \nThe function takes an input parameter named `request`, which is typically an HTTP request object in Django. This object can contain user-originated data such as query parameters, form data, cookies, and more.\n\nMain Functionality:  \nThe function `my2sql` is a Django view that requires a specific permission (`sql.menu_my2sql`) to be accessed. If the user does not have this permission, an exception is raised. The primary purpose of the function is to render a web page, specifically `my2sql.html`.\n\nOutputs / Return Values:  \nThe function returns an HTTP response object generated by rendering the `my2sql.html` template. This response is typically an HTML page displayed to the user in their web browser."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "schemasync",
        "lineno": 521,
        "summarize": "User Input Sources:  \nThe function `schemasync` takes a `request` object as input, which is typical in Django views. This `request` object can contain user-originated data such as HTTP request parameters, including GET and POST data, cookies, and other request metadata.\n\nMain Functionality:  \nThe primary purpose of the `schemasync` function is to render and return a web page for database schema comparison. It is a Django view function that serves an HTML page named \"schemasync.html\". The function is decorated with `@permission_required`, which ensures that the user has the \"sql.menu_schemasync\" permission before accessing the view. If the user does not have the required permission, an exception is raised.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing the rendered \"schemasync.html\" page. If the user does not have the necessary permissions, it raises an exception, likely resulting in an HTTP error response."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "archive",
        "lineno": 527,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which typically originates from an HTTP request in a web application context. The `request` object contains information about the user making the request, such as the user object (`request.user`).\n\nMain Functionality:  \n- The function `archive` is designed to render an archive list page in a web application. It first retrieves a list of user groups that the current user belongs to by calling the `user_groups` function with `request.user` as an argument. It then fetches a list of user instances related to MySQL databases by invoking the `user_instances` function with `request.user` and specifying the database type. The instances are ordered by their name in ascending order based on a specific character encoding (GBK). Finally, the function renders an HTML page (`archive.html`) with the retrieved group and instance lists passed as context.\n\nOutputs / Return Values:  \n- The function returns an HTTP response generated by the `render` function, which includes an HTML page (`archive.html`). The context of this page contains two lists: `group_list` and `ins_list`, which represent the user's groups and MySQL instances, respectively."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "archive_detail",
        "lineno": 539,
        "summarize": "User Input Sources:  \n- The function takes a `request` object and an `id` as input parameters. The `request` object typically comes from an HTTP request, which can include user input such as URL parameters, form data, or headers. The `id` is used to fetch a specific `ArchiveConfig` object and could originate from a URL parameter or a form submission.\n\nMain Functionality:  \n- The function `archive_detail` is designed to render a detailed view of an archive configuration. It retrieves an `ArchiveConfig` object based on the provided `id`. It then initializes an `AuditV2` object to handle audit-related operations, including checking if the current user (`request.user`) can perform audit operations on the workflow. It also retrieves audit logs if the archive configuration's status indicates it has been processed. Additionally, it gathers information about current reviewers from the audit workflow, particularly those associated with the same resource group as the archive configuration.\n\nOutputs / Return Values:  \n- The function returns an HTTP response rendered with the template \"archivedetail.html\". The context passed to the template includes details about the `archive_config`, a list of `current_reviewers`, `review_info`, `last_operation_info`, and a boolean `can_review` indicating whether the user can review the archive."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "config",
        "lineno": 589,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which typically originates from an HTTP request. This means it could include data from URL parameters, form submissions, cookies, or other HTTP request data.\n\nMain Functionality:  \nThe primary purpose of the function is to prepare data for rendering a configuration management webpage. It retrieves various sets of data from the database, including resource groups, authorization groups, instance tags, and configuration items. It also sets default values for certain OpenAI-related configurations if they are not present. This data is then compiled into a context dictionary to be used for rendering an HTML page.\n\nOutputs / Return Values:  \nThe function returns an HTML page rendered with the context data, specifically \"config.html\". The context includes lists of resource groups, authorization groups, instance tags, supported database types, configuration settings, and workflow choices."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "audit",
        "lineno": 673,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which is typical in Django web applications. This object can contain data originating from the user, such as HTTP request parameters, cookies, or session data.\n\nMain Functionality:  \nThe primary purpose of the `audit` function is to generate a web page for auditing logs. It retrieves distinct action types from the `AuditEntry` model in the database, which are then used to populate the context for rendering an HTML page. The function is decorated with `@permission_required(\"sql.audit_user\", raise_exception=True)`, ensuring that only users with the specified permission can access this view, otherwise an exception is raised.\n\nOutputs / Return Values:  \nThe function returns an HTTP response generated by the `render` function. This response is an HTML page (`audit.html`) that includes the list of distinct action types from the `AuditEntry` model, passed in the context as `action_types`."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "audit_sqlquery",
        "lineno": 681,
        "summarize": "User Input Sources:  \n- The function takes a `request` object as input, which is typically provided by the Django framework when handling an HTTP request. This object can contain user-related data such as session information, user authentication details, and possibly other request parameters.\n\nMain Functionality:  \n- The primary purpose of the `audit_sqlquery` function is to serve an HTML page that audits SQL queries. It checks for user permissions using the `@permission_required` decorator, ensuring that only users with the \"sql.audit_user\" permission can access this functionality. The function retrieves a list of SQL query logs marked as favorites by the current user from the `QueryLog` model, specifically fetching the `id` and `alias` fields. This list of favorite queries is then passed to the HTML template `audit_sqlquery.html`.\n\nOutputs / Return Values:  \n- The function returns an HTTP response generated by the `render` function, which combines the `audit_sqlquery.html` template with the context data containing the user's favorite SQL queries. The output is an HTML page displayed to the user."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "audit_sqlworkflow",
        "lineno": 690,
        "summarize": "User Input Sources:  \nThe function `audit_sqlworkflow` takes input from an HTTP request object, specifically from the `request` parameter. The input of interest is the `user` attribute of the request, which includes user permissions and group memberships that are used to filter SQL workflows.\n\nMain Functionality:  \nThe core purpose of the function is to display a list of SQL workflows based on the user's permissions and group memberships. It checks the user's permissions to determine the scope of SQL workflows they can view:\n- If the user is a superuser or has the `sql.audit_user` permission, they can view all workflows.\n- If the user has the `sql.sql_review` or `sql.sql_execute_for_resource_group` permission, they can view workflows within their resource groups.\n- Otherwise, the user can only view workflows they have submitted.\n\nBased on these checks, the function filters the SQL workflows accordingly and retrieves the related instances and resource groups.\n\nOutputs / Return Values:  \nThe function returns an HTTP response rendered with the `audit_sqlworkflow.html` template. The response includes the following data:\n- `status_list`: A list of SQL workflow status choices.\n- `instance`: A queryset of instances related to the filtered SQL workflows.\n- `resource_group`: A queryset of resource groups related to the filtered SQL workflows."
    },
    {
        "file_path": "common\\auth.py",
        "scope": "authenticate_entry",
        "lineno": 120,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, `request`, which likely includes parameters such as username and password. These could be sent via HTTP request headers, POST data, or other request attributes.\n\nMain Functionality:  \n- The function is designed to authenticate a user based on credentials provided in an HTTP request. It utilizes the `ArcheryAuth` class to verify the credentials. If authentication is successful, it checks if two-factor authentication (2FA) is enabled globally and whether the user has 2FA configured. Depending on these checks, it sets up a session with a specific `verify_mode`. If 2FA is not enforced globally and the user does not have 2FA configured, the function directly logs in the user and optionally retrieves a DingDing user ID to send messages if configured. The function aims to securely manage user authentication and session handling, especially concerning 2FA.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponse` object containing a JSON-formatted string. This JSON object includes a `status` key indicating the authentication result, a `msg` key with a message, and a `data` key that holds either the session key or `None`, depending on the authentication and 2FA status."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "sql_workflow_list",
        "lineno": 39,
        "summarize": "User Input Sources:  \nThe function `sql_workflow_list` takes a single parameter `request`, which is likely an HTTP request object. This means it can contain user input from various sources such as query parameters, form data, cookies, and HTTP headers.\n\nMain Functionality:  \nThe primary purpose of the `sql_workflow_list` function is to serve as a wrapper for another function named `_sql_workflow_list`. It is decorated with `@permission_required(\"sql.menu_sqlworkflow\", raise_exception=True)`, which indicates that the function checks whether the user has the required permission (\"sql.menu_sqlworkflow\") before executing. If the user does not have the necessary permissions, an exception will be raised, preventing access to the underlying functionality.\n\nOutputs / Return Values:  \nThe function returns whatever the `_sql_workflow_list` function returns. Since the exact implementation of `_sql_workflow_list` is not provided, it is unclear what specific data type or content it returns. However, it is likely to return an HTTP response object, which could be an HTML page, JSON object, or other web content, depending on the implementation of `_sql_workflow_list`."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "sql_workflow_list_audit",
        "lineno": 44,
        "summarize": "User Input Sources:  \nThe function `sql_workflow_list_audit` takes a single parameter `request`, which is likely an HTTP request object. This means it can include input from various user-originated sources such as HTTP request parameters, headers, cookies, or body data.\n\nMain Functionality:  \nThe primary purpose of the `sql_workflow_list_audit` function is to act as a wrapper around another function named `_sql_workflow_list`. It is decorated with `@permission_required(\"sql.audit_user\", raise_exception=True)`, which ensures that the user making the request has the necessary permission \"sql.audit_user\". If the user lacks this permission, an exception will be raised. If the permission check is passed, the function proceeds to call `_sql_workflow_list` with the request object.\n\nOutputs / Return Values:  \nThe function returns whatever is produced by the `_sql_workflow_list` function. Without the specific implementation details of `_sql_workflow_list`, it is unclear what type of data is returned, but it could be an HTML page, JSON object, or another data format typically returned in web applications."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "detail_content",
        "lineno": 136,
        "summarize": "User Input Sources:  \nThe function `detail_content` takes user input from an HTTP GET request parameter named `workflow_id`. This parameter is accessed via `request.GET.get(\"workflow_id\")`. Additionally, the function checks the user's permissions using `request.user`.\n\nMain Functionality:  \nThe primary purpose of the `detail_content` function is to retrieve and return details of a specific SQL workflow based on the provided `workflow_id`. It first attempts to fetch the workflow details using the `get_object_or_404` function. It then checks if the requesting user has permission to view the workflow using the `can_view` function. Depending on the workflow's status, it retrieves either the execution result or the review content. The function attempts to parse this data as JSON. If the data is in an old format or if JSON decoding fails, it handles these cases by converting or reporting an error. The function then prepares the result as a JSON object.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object. This JSON object contains a key \"rows\" with the parsed or processed workflow details. The content type of the response is set to `application/json`."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "backup_sql",
        "lineno": 185,
        "summarize": "User Input Sources:  \n- The function takes user input through an HTTP request parameter, specifically `workflow_id`, which is retrieved from `request.GET`.\n- The user's identity is also indirectly used through `request.user` to check permissions.\n\nMain Functionality:  \n- The function is designed to generate and return SQL rollback statements associated with a specific workflow.\n- It first checks if the user has permission to perform a rollback on the specified workflow by calling `can_rollback`.\n- If the user does not have permission, it raises a `PermissionDenied` exception.\n- It retrieves the `SqlWorkflow` object using the `workflow_id`.\n- It then obtains a query engine instance for the workflow's database instance and calls `get_rollback` to generate the rollback SQL statements.\n- If an exception occurs during the retrieval of rollback statements, it logs the error and returns a JSON response indicating failure.\n\nOutputs / Return Values:  \n- On success, it returns an HTTP response with a JSON object containing the rollback SQL statements in the `rows` key, along with a status code of 0 and an empty message.\n- On failure (either permission denial or exception during processing), it returns a JSON response with a status code of 1 and an error message."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "get_workflow_status",
        "lineno": 499,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request. Specifically, it expects a parameter named \"workflow_id\" within the POST data of the request.\n\nMain Functionality:  \nThe function's core purpose is to retrieve the current status of a specific workflow, identified by its ID. It first checks if the \"workflow_id\" is provided and is not empty. If the \"workflow_id\" is missing or empty, it returns an error message. Otherwise, it converts the \"workflow_id\" to an integer, retrieves the corresponding workflow object from the database using the `get_object_or_404` function, and extracts the status of that workflow.\n\nOutputs / Return Values:  \nThe function returns a JSON response. If the \"workflow_id\" is not provided or is empty, it returns a JSON object with a status of -1 and an error message. If the workflow is found, it returns a JSON object containing the workflow's status."
    },
    {
        "file_path": "sql\\utils\\tasks.py",
        "scope": "del_schedule",
        "lineno": 53,
        "summarize": "User Input Sources:  \nThe function `del_schedule` takes a single parameter `name`, which could originate from user input. This input could be derived from various sources such as HTTP request parameters, command-line arguments, or other user-provided data.\n\nMain Functionality:  \nThe core purpose of the function is to delete a schedule entry from a database. It attempts to retrieve a schedule object with the specified `name` from the database using the `Schedule.objects.get(name=name)` method. If the schedule with the given name exists, it deletes the schedule using `Schedule.delete(sql_schedule)`. The function logs a debug message indicating the deletion of the schedule. If the schedule does not exist, it catches the `Schedule.DoesNotExist` exception and does nothing.\n\nOutputs / Return Values:  \nThe function does not return any value. Its main side effects are deleting a schedule from the database and logging a debug message."
    },
    {
        "file_path": "sql\\sql_workflow.py",
        "scope": "osc_control",
        "lineno": 514,
        "summarize": "User Input Sources:  \nThe function `osc_control` takes user input from an HTTP request object, specifically from POST parameters. The inputs are:  \n- `workflow_id`: Retrieved from `request.POST.get(\"workflow_id\")`.\n- `sqlsha1`: Retrieved from `request.POST.get(\"sqlsha1\")`.\n- `command`: Retrieved from `request.POST.get(\"command\")`.\n\nMain Functionality:  \nThe core purpose of the function is to control the execution of an online schema change (OSC) process for a MySQL database. It does this by:  \n1. Retrieving a `SqlWorkflow` object using the `workflow_id`.\n2. Obtaining an execution engine instance associated with the workflow's database instance.\n3. Using this engine to execute a control command on the OSC process, passing the `command` and `sqlsha1` as arguments.\n4. Handling the execution result by converting it to a dictionary and capturing any errors that occur during the process.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes:  \n- `total`: The number of rows returned by the execution result.\n- `rows`: The result of the OSC control command execution, converted to a dictionary.\n- `msg`: Any error message captured during the execution, or an empty string if no error occurred."
    },
    {
        "file_path": "sql\\sql_analyze.py",
        "scope": "generate",
        "lineno": 26,
        "summarize": "User Input Sources:  \nThe function takes input from the user through an HTTP request, specifically from the POST parameters of the request object. The parameter of interest is \"text\", which can be provided by the user.\n\nMain Functionality:  \nThe core purpose of this function is to parse the content of the uploaded text and convert it into a list of SQL statements. It first checks if the \"text\" parameter is provided in the POST request. If it is not provided, it sets the result as an empty list with a total count of zero. If the \"text\" is present, it calls the `generate_sql` function with the text to generate a list of SQL statements, then constructs a result dictionary containing the total number of SQL statements and the list of those statements.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes a \"total\" key with the count of SQL statements and a \"rows\" key with the list of SQL statements generated from the input text. The JSON is encoded using a custom JSON encoder (`ExtendJSONEncoder`) and is returned with the content type set to \"application/json\"."
    },
    {
        "file_path": "sql\\sql_analyze.py",
        "scope": "analyze",
        "lineno": 45,
        "summarize": "User Input Sources:  \n- The function receives input from the `request` object, specifically through HTTP POST parameters: `text`, `instance_name`, and `db_name`. These parameters are provided by the user making the HTTP request.\n\nMain Functionality:  \n- The function is designed to analyze SQL statements using a tool named `soar`. It first retrieves SQL text and database connection details from the HTTP POST request. If the `text` parameter is empty, it returns an empty result set. If both `instance_name` and `db_name` are provided, it attempts to retrieve the corresponding database instance for the user. If the instance is not found, it returns an error message. Otherwise, it constructs connection strings for the online and test databases. The function then processes each SQL statement from the `text`, ensuring none of them are file paths. For each valid SQL statement, it generates command-line arguments for `soar`, executes the command, and collects the output. The function finally returns the analysis report for each SQL statement.\n\nOutputs / Return Values:  \n- The function returns an HTTP response with a JSON object. The JSON includes a `total` count of analyzed SQL statements and a `rows` array containing details of each SQL statement and its corresponding analysis report. If an error occurs, such as an invalid SQL or missing database instance, the function returns a JSON response with a status code and an error message."
    },
    {
        "file_path": "common\\workflow.py",
        "scope": "lists",
        "lineno": 12,
        "summarize": "User Input Sources:  \n- The function receives input from the `request` object, which is typical in web frameworks like Django.\n- It specifically uses `request.POST` to retrieve parameters: `limit`, `offset`, `workflow_type`, and an optional `search` string.\n- `request.user` is used to obtain the user information, which could also be considered user input as it depends on the current authenticated user making the request.\n\nMain Functionality:  \n- The function is designed to retrieve and return a list of workflow audit records that the user is authorized to review.\n- It starts by identifying the resource groups and authorization groups the user belongs to. For superusers, it retrieves all authorization groups.\n- It then filters the `WorkflowAudit` records to include only those that are in a \"waiting\" status, belong to the user's resource groups, and match the user's authorization groups.\n- If a specific `workflow_type` is provided (other than 0), it further filters the results by this type.\n- The results are ordered by `audit_id` in descending order and paginated using the `offset` and `limit` values.\n- The filtered and paginated results are serialized into a list of dictionaries, each representing a workflow audit record.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object.\n- The JSON object includes the total count of matching workflow audit records (`total`) and a list of the records (`rows`) with specific fields: `audit_id`, `workflow_type`, `workflow_title`, `create_user_display`, `create_time`, `current_status`, `audit_auth_groups`, `current_audit`, and `group_name`."
    },
    {
        "file_path": "common\\workflow.py",
        "scope": "log",
        "lineno": 67,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request object, specifically from the POST data. It retrieves the values of \"workflow_id\" and \"workflow_type\" using `request.POST.get()`.\n\nMain Functionality:  \nThe function's primary purpose is to retrieve logs related to a specific workflow identified by \"workflow_id\" and \"workflow_type\". It queries a `WorkflowAudit` model to find an `audit_id` associated with these identifiers. Using this `audit_id`, it retrieves and orders related log entries from a `WorkflowLog` model. If an exception occurs during these operations, it defaults to an empty list of logs and a count of zero.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes a \"total\" key with the count of log entries and a \"rows\" key with a list of log details. The JSON response is encoded using a custom encoder `ExtendJSONEncoderFTime` and formatted to treat big integers as strings. The content type of the response is set to \"application/json\"."
    },
    {
        "file_path": "common\\config.py",
        "scope": "change_config",
        "lineno": 106,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request parameter named \"configs\". This input is accessed via `request.POST.get(\"configs\")`, indicating that the data comes from a web form or an HTTP request body.\n\nMain Functionality:  \nThe function is designed to change system configurations. It utilizes the `SysConfig` class, presumably to handle system configuration settings. The function calls the `replace` method on an instance of `SysConfig`, passing the user-provided configuration data (`configs`) to it. The core purpose is to update or replace existing configurations with the new data provided by the user.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object is the result of the `replace` method call on the `SysConfig` instance. The response is constructed using `HttpResponse` with the JSON data and a content type of \"application/json\", indicating that the output is meant to be consumed as a JSON object by the client."
    },
    {
        "file_path": "common\\check.py",
        "scope": "go_inception",
        "lineno": 20,
        "summarize": "User Input Sources:  \nThe function takes input from HTTP POST request parameters. Specifically, it retrieves the following parameters from the request:  \n- `go_inception_host`\n- `go_inception_port`\n- `go_inception_user`\n- `go_inception_password`\n- `inception_remote_backup_host`\n- `inception_remote_backup_port`\n- `inception_remote_backup_user`\n- `inception_remote_backup_password`\n\nMain Functionality:  \nThe primary purpose of the function is to establish two separate MySQL database connections using the provided credentials from the HTTP POST request. It first attempts to connect to a database specified by the `go_inception` parameters. If this connection fails, it logs an error and returns a JSON response indicating the failure. If successful, it closes the connection and proceeds to attempt a second connection using the `inception_remote_backup` parameters. This connection is also logged and returned in a similar manner. The function is decorated with `@superuser_required`, indicating it requires superuser privileges to execute.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object. The JSON object contains:\n- A `status` key, indicating the success (0) or failure (1) of the connection attempts.\n- A `msg` key, providing a message about the connection status or error details.\n- A `data` key, which is an empty list in this implementation."
    },
    {
        "file_path": "common\\check.py",
        "scope": "email",
        "lineno": 76,
        "summarize": "User Input Sources:  \nThe function takes input from HTTP POST request parameters. Specifically, it retrieves the following parameters from the request: `mail`, `mail_ssl`, `mail_smtp_server`, `mail_smtp_port`, `mail_smtp_user`, and `mail_smtp_password`. Additionally, it accesses the current user's email address via `request.user.email`.\n\nMain Functionality:  \nThe core purpose of the function is to send a test email using the SMTP protocol. It first checks if the email notifications are enabled by evaluating the `mail` parameter. If email notifications are not enabled, it returns an error message. The function then validates that the SMTP port is a positive integer. If the port is invalid, it returns an error message. It also checks if the user's email is set; if not, it returns an error message. If all checks pass, it attempts to send a test email using the provided SMTP server details. The function utilizes a `MsgSender` class to handle the email sending process. If the email sending fails, it returns an error message with the failure reason.\n\nOutputs / Return Values:  \nThe function returns a JSON object wrapped in an HTTP response. The JSON object contains a `status` field (0 for success, 1 for failure), a `msg` field with a message indicating the result of the operation, and a `data` field, which is an empty list. The messages may include specific error messages or \"ok\" if the email sending is successful."
    },
    {
        "file_path": "common\\check.py",
        "scope": "instance",
        "lineno": 120,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request. Specifically, it retrieves the \"instance_id\" parameter from the request's POST data.\n\nMain Functionality:  \nThe primary purpose of the function is to test the connection to a specific instance identified by the \"instance_id\". It retrieves the instance from the database using the provided \"instance_id\", then attempts to establish a connection using a method called `get_engine`. The function checks if the connection test was successful or if there was an error. If an error occurs during the connection test or if an exception is raised, the function updates the result to indicate the failure and includes the error message.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes a \"status\" key, which is 0 for success and 1 for failure, a \"msg\" key with a message indicating the result of the connection test, and a \"data\" key, which is an empty list in this implementation."
    },
    {
        "file_path": "common\\check.py",
        "scope": "file_storage_connect",
        "lineno": 138,
        "summarize": "User Input Sources:  \nThe function `file_storage_connect` takes input from an HTTP POST request, specifically from the `request.POST` dictionary. It retrieves several parameters that could originate from user input, including:\n- `storage_type`\n- `max_export_rows`\n- Custom parameters based on the storage type (e.g., `sftp_custom_params`, `s3c_custom_params`, `azure_custom_params`)\n- Various configuration details such as `sftp_host`, `sftp_port`, `sftp_user`, `sftp_password`, `s3c_access_key_id`, `s3c_access_key_secret`, `azure_account_name`, and others.\n\nMain Functionality:  \nThe core purpose of the `file_storage_connect` function is to establish a connection to a specified storage service (such as SFTP, S3-compatible storage, or Azure storage) using configuration parameters provided in the HTTP POST request. It performs the following actions:\n1. Validates the `max_export_rows` parameter to ensure it is an integer.\n2. Retrieves and parses custom parameters for the specified storage type, ensuring they are in valid JSON format.\n3. Constructs a configuration dictionary using the provided parameters.\n4. Attempts to connect to the storage service using the `DynamicStorage` class and its `check_connection` method.\n5. Logs the success or failure of the connection attempt.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object. This JSON object contains:\n- A `status` key indicating success (0) or failure (1).\n- A `msg` key with a message describing the outcome, such as \"ok\", \"\u53c2\u6570\u7c7b\u578b\u9519\u8bef\", \"\u81ea\u5b9a\u4e49\u53c2\u6570\u683c\u5f0f\u9519\u8bef\uff0c\u8bf7\u8f93\u5165\u6709\u6548\u7684JSON\u683c\u5f0f\", or \"\u5b58\u50a8\u8fde\u63a5\u6d4b\u8bd5\u5931\u8d25\".\n- A `data` key, which is an empty list in this implementation."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "group",
        "lineno": 21,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request, specifically using the POST method. The inputs include:\n- `limit`: Retrieved from `request.POST.get(\"limit\")`, expected to be an integer.\n- `offset`: Retrieved from `request.POST.get(\"offset\")`, expected to be an integer.\n- `search`: Retrieved from `request.POST.get(\"search\")`, with a default value of an empty string if not provided.\n\nMain Functionality:  \nThe core purpose of the function is to retrieve a list of resource groups from a database. It filters the groups based on a search term provided by the user and ensures that the groups have not been marked as deleted. The function then calculates the total number of groups that match the search criteria and retrieves a paginated list of groups based on the provided `limit` and `offset` values. The function serializes the result into a JSON-compatible format.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes:\n- `total`: The total number of resource groups that match the search criteria.\n- `rows`: A list of dictionaries, each representing a resource group with fields `group_id`, `group_name`, and `ding_webhook`. The response is serialized using a custom JSON encoder (`ExtendJSONEncoder`) and includes the content type `application/json`."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "addrelation",
        "lineno": 175,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP POST request, specifically from the `request.POST` dictionary. The inputs include:\n- `group_id`: Retrieved and converted to an integer from `request.POST.get(\"group_id\")`.\n- `object_type`: Retrieved as a string from `request.POST.get(\"object_type\")`.\n- `object_info`: Retrieved and parsed as a JSON list from `request.POST.get(\"object_info\")`.\n\nMain Functionality:  \nThe core purpose of this function is to add associations between a resource group and other objects, which can be either users or instances. It does this by:\n1. Retrieving the resource group using the provided `group_id`.\n2. Parsing the `object_info` to extract object IDs.\n3. Depending on the `object_type`, it adds the objects to the appropriate relationship set of the resource group:\n   - If `object_type` is \"0\", it associates users with the resource group.\n   - If `object_type` is \"1\", it associates instances with the resource group.\n4. It logs an error if an exception occurs during the process.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object. The JSON object contains:\n- A `status` key with a value of `0` for success or `1` for failure.\n- A `msg` key with a value of `\"ok\"` for success or the exception message in case of an error. The response is returned with a content type of `\"application/json\"`."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "associated_objects",
        "lineno": 46,
        "summarize": "User Input Sources:  \nThe function `associated_objects` takes input from an HTTP POST request. Specifically, it uses the following parameters from the request:\n- `group_id`: Retrieved and converted to an integer from `request.POST.get(\"group_id\")`.\n- `type`: Retrieved from `request.POST.get(\"type\")`.\n- `limit`: Retrieved and converted to an integer from `request.POST.get(\"limit\")`.\n- `offset`: Retrieved and converted to an integer from `request.POST.get(\"offset\")`.\n- `search`: Retrieved from `request.POST.get(\"search\")`.\n\nMain Functionality:  \nThe primary purpose of the `associated_objects` function is to retrieve and return information about objects associated with a resource group. It first fetches the resource group based on the provided `group_id`. Depending on the `type` parameter, it either retrieves users or instances associated with the resource group. If a `search` parameter is provided, it filters the results based on whether the users' display names or instances' names contain the search term. The function then annotates the data with additional fields such as `object_id`, `object_type`, `object_name`, `group_id`, and `group_name`. Finally, it applies pagination using the `limit` and `offset` parameters.\n\nOutputs / Return Values:  \nThe function returns a JSON object wrapped in an HTTP response. The JSON object includes:\n- `status`: A status code (0 in this case, indicating success).\n- `msg`: A message string (\"ok\").\n- `total`: The total number of objects matching the criteria.\n- `rows`: A list of objects (users or instances) with their associated information, limited and offset as specified by the input parameters."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "instances",
        "lineno": 130,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, specifically using the `POST` method. It retrieves `group_name`, `tag_code`, and `db_type` from the `request.POST` dictionary. These values are potentially provided by the user through an HTTP request.\n\nMain Functionality:  \n- The function's primary purpose is to retrieve and filter a list of instances associated with a specified resource group. It first obtains the `group_id` by querying the `ResourceGroup` model with the provided `group_name`. It then retrieves all instances related to this `group_id`. The function applies filters based on `db_type` and `tag_code` if they are provided. The filtered instances are ordered by `instance_name` in ascending order using a GBK encoding for sorting. Finally, it constructs a list of dictionaries containing specific fields (`id`, `type`, `db_type`, `instance_name`) from the filtered instances.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. The JSON object includes a status code (`status`), a message (`msg`), and the filtered instance data (`data`). The data is a list of dictionaries, each representing an instance with selected fields."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "unassociated_objects",
        "lineno": 99,
        "summarize": "User Input Sources: \nThe function takes user input from an HTTP request object, specifically from the `POST` parameters. It extracts `group_id` and `object_type` from `request.POST`.\n\nMain Functionality: \nThe function aims to retrieve unassociated objects within a resource group based on the specified object type. It first fetches the resource group using the provided `group_id`. If the `object_type` is 0, it identifies users not associated with the resource group and gathers their IDs and display names. If the `object_type` is 1, it identifies instances not associated with the resource group and gathers their IDs and instance names. If an invalid `object_type` is provided, it raises a `ValueError`.\n\nOutputs / Return Values: \nThe function returns an HTTP response containing a JSON object. This JSON object includes the status of the operation, a message, a list of unassociated objects (each with an `object_id` and `object_name`), and the total count of these objects."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "auditors",
        "lineno": 197,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP POST request. It specifically extracts the values of \"group_name\" and \"workflow_type\" from the `request.POST` dictionary, which are typically user-provided data in web applications.\n\nMain Functionality:  \nThe primary purpose of the function is to retrieve and verify the approval process for a specified resource group. It first attempts to get a `group_id` based on the provided `group_name`. If `group_name` is not provided, it returns an error message indicating a parameter error. It then fetches a list of audit authorization groups associated with the `group_id` and `workflow_type`. The function checks if each authorization group ID is valid by attempting to retrieve the corresponding group object. If any group ID is invalid, it returns an error message. If all group IDs are valid, it constructs a display string of group names and updates the result data with the auditors' IDs and display names.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes a status code, a message, and data with details about the auditors and their display names. If there are errors, the status code is set to 1 with an appropriate error message."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "changeauditors",
        "lineno": 239,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object `request`, specifically using the `POST` method. It retrieves the following parameters from the POST data:\n  - `audit_auth_groups`: A string of comma-separated group names.\n  - `group_name`: The name of the resource group.\n  - `workflow_type`: The type of workflow.\n\nMain Functionality:  \n- The primary purpose of the function is to modify the approval process for a resource group. It does this by:\n  1. Retrieving the `group_id` of a resource group using the `group_name`.\n  2. Converting the `audit_auth_groups` from a comma-separated string of group names into a list of group IDs.\n  3. Calling `Audit.change_settings` to update the workflow configuration with the specified `group_id`, `workflow_type`, and `audit_auth_groups`.\n  4. Handling any exceptions that occur during the update process, logging the error, and updating the result status and message accordingly.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponse` containing a JSON object. This JSON object includes:\n  - `status`: An integer indicating success (`0`) or failure (`1`).\n  - `msg`: A message string, either \"ok\" for success or an error message for failure.\n  - `data`: An empty list, which appears to be reserved for additional data but is not utilized in this function."
    },
    {
        "file_path": "sql\\resource_group.py",
        "scope": "user_all_instances",
        "lineno": 158,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, specifically using the query parameters:\n  - `type`: Retrieved using `request.GET.get(\"type\")`.\n  - `db_type`: Retrieved as a list using `request.GET.getlist(\"db_type[]\")`.\n  - `tag_codes`: Retrieved as a list using `request.GET.getlist(\"tag_codes[]\")`.\n- The `request.user` object is used to identify the user making the request.\n\nMain Functionality:  \n- The function's core purpose is to retrieve a list of instances associated with a user through resource groups. It does this by calling the `user_instances` function with the user and query parameters as arguments. The resulting instances are sorted by `instance_name` in ascending order using the GBK encoding for collation. The function extracts specific fields (`id`, `type`, `db_type`, `instance_name`) from each instance and compiles them into a list.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. The JSON object includes a status code (`status: 0`), a message (`msg: \"ok\"`), and a data field (`data`) that contains a list of instances, each represented as a dictionary with the specified fields."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "lists",
        "lineno": 22,
        "summarize": "User Input Sources:  \nThe function `lists` receives user input from an HTTP POST request. The inputs that can originate from the user include:\n- `limit`: Retrieved from `request.POST.get(\"limit\")`, it determines the number of records to return.\n- `offset`: Retrieved from `request.POST.get(\"offset\")`, it specifies the starting point for records to return.\n- `type`: Retrieved from `request.POST.get(\"type\")`, it filters the instances by type.\n- `db_type`: Retrieved from `request.POST.get(\"db_type\")`, it filters the instances by database type.\n- `tags`: Retrieved from `request.POST.getlist(\"tags[]\")`, it filters instances by tags.\n- `search`: Retrieved from `request.POST.get(\"search\", \"\")`, it is used to search instances by name.\n- `sortName`: Retrieved from `request.POST.get(\"sortName\")`, it specifies the field to sort by.\n- `sortOrder`: Retrieved from `request.POST.get(\"sortOrder\")`, it specifies the sort order (ascending or descending).\n\nMain Functionality:  \nThe main purpose of the `lists` function is to retrieve and return a list of database instances based on various filtering and sorting criteria provided by the user. It constructs a query based on user inputs such as search terms, instance type, database type, and tags. The function then applies sorting and pagination based on the `limit`, `offset`, `sortName`, and `sortOrder` parameters. It retrieves the relevant data from the `Instance` model and prepares it for serialization into JSON format.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This object includes:\n- `total`: The total number of instances that match the filtering criteria.\n- `rows`: A list of dictionaries, each representing an instance with fields like `id`, `instance_name`, `db_type`, `type`, `host`, `port`, and `user`. The data is serialized using a custom JSON encoder, `ExtendJSONEncoder`."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "users",
        "lineno": 21,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP POST request. It specifically extracts the following parameters from the request:\n- `instance_id`: Retrieved using `request.POST.get(\"instance_id\")`, which is expected to be a string representing the ID of a database instance.\n- `saved`: Retrieved using `request.POST.get(\"saved\")`, which is a string expected to be either \"true\" or some other value, indicating whether to filter the users based on a saved status.\n\nMain Functionality:  \nThe function's core purpose is to retrieve a list of users associated with a specific database instance. It first checks if the `instance_id` is provided and verifies if the instance exists for the user. If the instance is not found, it returns an error message. It then retrieves a list of users already recorded for the instance and a summary of all users from the database engine. It merges these two lists and filters them based on the `saved` parameter. Finally, it constructs a result object containing the status, a message, and the list of users.\n\nOutputs / Return Values:  \nThe function returns a JSON response. The JSON object includes:\n- `status`: An integer indicating the success (0) or failure (1) of the operation.\n- `msg`: A message string, which is either \"ok\" or an error message.\n- `rows`: A list of user dictionaries, each containing user details such as `id`, `user`, `host`, `db_name`, `remark`, and `saved`. If the `saved` parameter is set to true, only users with `saved` status are included in the list."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "create",
        "lineno": 70,
        "summarize": "User Input Sources:  \nThe function `create` takes user input from an HTTP request object, specifically using the POST method. The inputs it retrieves from the request include:\n- `instance_id`: retrieved using `request.POST.get(\"instance_id\", 0)`.\n- `db_name`: retrieved using `request.POST.get(\"db_name\")`.\n- `user`: retrieved using `request.POST.get(\"user\")`.\n- `host`: retrieved using `request.POST.get(\"host\")`.\n- `password1`: retrieved using `request.POST.get(\"password1\")`.\n- `password2`: retrieved using `request.POST.get(\"password2\")`.\n- `remark`: retrieved using `request.POST.get(\"remark\", \"\")`.\n\nMain Functionality:  \nThe core purpose of the function `create` is to create a new database account for a specified database instance. The function first checks if the user has the necessary permissions to manage SQL instance accounts. It then attempts to retrieve the database instance based on the provided `instance_id`. If the instance does not exist or required parameters are missing, it returns an error message. The function also checks if the two provided passwords match and validates the password using a validation function. If all checks pass, it uses an engine to create the database user and stores the account information in the database. If any error occurs during user creation, it returns an error message.\n\nOutputs / Return Values:  \nThe function returns a JSON response using `JsonResponse`. The JSON object contains:\n- `status`: An integer indicating the success or failure of the operation (0 for success, 1 for failure).\n- `msg`: A message string providing feedback on the operation's outcome, such as errors or success messages.\n- `data`: A list, which is empty in the current implementation."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "edit",
        "lineno": 123,
        "summarize": "User Input Sources:  \nThe function `edit` takes input from an HTTP POST request. The user input sources include the following parameters obtained from `request.POST`: `instance_id`, `db_name`, `user`, `host`, `password`, and `remark`. These parameters can originate from user-submitted form data.\n\nMain Functionality:  \nThe primary purpose of the `edit` function is to modify or input a database account. It first retrieves the `instance_id`, `db_name`, `user`, `host`, `password`, and `remark` from the POST request. It then attempts to fetch a database instance associated with the current user and the specified `instance_id`. If the instance does not exist, it returns an error message. The function checks the completeness of required parameters based on the database type (MySQL or MongoDB). If parameters are incomplete, it returns an error message. If parameters are complete, it updates or creates a database account in the `InstanceAccount` model with the provided details, including updating the password if it is provided.\n\nOutputs / Return Values:  \nThe function returns a JSON response in all cases. If an error occurs (either due to a missing instance or incomplete parameters), it returns a JSON object with `status` set to 1 and an appropriate error message. If the operation is successful, it returns a JSON object with `status` set to 0 and an empty message and data field."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "grant",
        "lineno": 167,
        "summarize": "User Input Sources:  \n- The function takes user input from the `request.POST` object, which is typical in a web application where data is submitted via HTTP POST requests. Specifically, it retrieves:\n  - `instance_id`\n  - `user_host`\n  - `op_type`\n  - `priv_type`\n  - `privs` (expected to be a JSON object)\n  - `db_name[]` (as a list)\n  - `tb_name[]` (as a list)\n  - `col_name[]` (as a list)\n  - `db_name_user`\n  - `roles[]` (as a list)\n\nMain Functionality:  \n- The function is designed to manage user permissions for database instances. It first retrieves a database instance based on the `instance_id` provided by the user. If the instance is of type \"mysql,\" it constructs SQL statements to grant or revoke user privileges based on the input parameters (`user_host`, `op_type`, `priv_type`, `privs`). The privileges can be global, database-specific, table-specific, or column-specific. The constructed SQL statements are then executed on the database. If the instance is of type \"mongo,\" it updates user roles directly through MongoDB's `updateUser` command. The function handles exceptions and returns an error message if any occur during the execution.\n\nOutputs / Return Values:  \n- The function returns a JSON response (`JsonResponse`) with the following possible structures:\n  - On successful execution of the privilege change, it returns `{\"status\": 0, \"msg\": \"\", \"data\": grant_sql}` where `grant_sql` is the SQL statement executed.\n  - On failure or incomplete information, it returns `{\"status\": 1, \"msg\": \"error message\", \"data\": []}` where \"error message\" explains the failure or missing information."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "reset_pwd",
        "lineno": 273,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request, specifically from the `request.POST` dictionary. This includes user-provided data such as `instance_id`, `db_name_user`, `db_name`, `user_host`, `user`, `host`, `reset_pwd1`, and `reset_pwd2`. These inputs could originate from a web form or API request.\n\nMain Functionality:  \nThe primary purpose of this function is to reset the password of a database account. It first checks if the user has the necessary permissions to manage database accounts. Then, it retrieves the database instance using the provided `instance_id`. If the instance does not exist or the required parameters are missing, it returns an error message. The function ensures that the two password fields (`reset_pwd1` and `reset_pwd2`) match and validates the password using a built-in validation method. If validation passes, it resets the password for the specified database user using a database engine. The function also updates or creates an `InstanceAccount` record in the database with the new password.\n\nOutputs / Return Values:  \nThe function returns a JSON response (`JsonResponse`) indicating the status of the operation. It includes a status code, a message, and additional data. In case of errors, it returns a status of 1 with an appropriate error message. If the password reset is successful, it returns a status of 0 with an empty message and data. Additionally, in case of an error during password reset execution, it returns an HTTP response with a JSON-encoded error message."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "lock",
        "lineno": 332,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request. Specifically, it retrieves the following parameters from the request:\n- `instance_id`: This is obtained using `request.POST.get(\"instance_id\", 0)`.\n- `user_host`: This is obtained using `request.POST.get(\"user_host\")`.\n- `is_locked`: This is obtained using `request.POST.get(\"is_locked\")`.\n\nMain Functionality:  \nThe function is designed to lock or unlock a database user account on a MySQL instance. It first checks if the necessary parameter `user_host` is provided. It then attempts to retrieve a database instance associated with the current user based on the `instance_id`. If the instance is found, it constructs a SQL command to either lock or unlock the user account depending on the value of `is_locked`. The constructed SQL command is executed on the MySQL instance to perform the lock/unlock operation.\n\nOutputs / Return Values:  \nThe function returns a JSON response:\n- If any required parameters are missing, it returns a JSON response indicating incomplete parameters.\n- If the instance is not found, it returns a JSON response indicating that the user's group is not associated with the instance.\n- If the SQL execution results in an error, it returns a JSON response with the error message.\n- If the operation is successful, it returns a JSON response with a status of 0, indicating success, and an empty message and data."
    },
    {
        "file_path": "sql\\instance_account.py",
        "scope": "delete",
        "lineno": 365,
        "summarize": "User Input Sources:  \nThe function `delete` takes user input from an HTTP request, specifically from POST parameters. The parameters include `instance_id`, `db_name_user`, `db_name`, `user_host`, `user`, and `host`. These are extracted using `request.POST.get()`.\n\nMain Functionality:  \nThe primary purpose of the `delete` function is to handle the deletion of a database account. It first retrieves the instance associated with the given `instance_id` for the requesting user. If the instance does not exist, it returns an error message. Depending on the database type (MySQL or MongoDB), it checks for the completeness of required parameters (`user_host` for MySQL and `db_name_user` for MongoDB). If the parameters are incomplete, it returns an error message. Otherwise, it uses an engine to execute the deletion of the user account from the database. If the deletion is successful, it also removes the corresponding record from the `InstanceAccount` database table.\n\nOutputs / Return Values:  \nThe function returns a JSON response using `JsonResponse`. The response includes a status code, a message, and additional data. If there are errors (like missing parameters, non-existent instances, or execution errors), it returns a status of 1 with an appropriate message. If the operation is successful, it returns a status of 0 with an empty message and data list."
    },
    {
        "file_path": "sql\\instance_database.py",
        "scope": "databases",
        "lineno": 24,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request, specifically through POST parameters. It uses `request.POST.get(\"instance_id\")` to obtain the `instance_id` and `request.POST.get(\"saved\")` to determine if only saved databases should be returned.\n\nMain Functionality:  \n- The function is designed to retrieve a list of databases associated with a specified instance. It first checks if the `instance_id` is provided; if not, it returns an empty data response. If the instance exists and is accessible by the user, it retrieves a list of databases that have been recorded in the system. It then queries the actual database instance to get a summary of all databases. The function compares the databases from the system's records with those obtained from the instance and combines the information. If the `saved` flag is set to true, it filters the list to include only those databases that have been marked as saved. It handles potential errors in querying the database and ensures that the database connection is closed after use.\n\nOutputs / Return Values:  \n- The function returns a JSON response. The response contains a status code (`0` for success, `1` for failure), a message indicating the result of the operation, and a list of database information (`rows`) if successful. If an error occurs during the database query, the response includes an error message. The JSON response is serialized with a custom JSON encoder (`ExtendJSONEncoder`) and is returned with a content type of `application/json`."
    },
    {
        "file_path": "sql\\instance_database.py",
        "scope": "create",
        "lineno": 71,
        "summarize": "User Input Sources:  \nThe function takes user input from the `request.POST` object, which is typically used to handle data submitted via an HTTP POST request. The specific parameters it extracts from this input are `instance_id`, `db_name`, `owner`, and `remark`.\n\nMain Functionality:  \nThe primary purpose of this function is to create a new database on a specified instance. It first checks if the necessary `db_name` parameter is provided. Then, it retrieves the database instance associated with the given `instance_id` and checks if the specified `owner` exists in the user database. Depending on the type of database instance (either MySQL or MongoDB), it attempts to create a new database. For MySQL, it executes a SQL command to create the database, while for MongoDB, it creates a collection to ensure the database's existence. It also manages database connections and handles exceptions during these operations.\n\nOutputs / Return Values:  \nThe function returns a `JsonResponse` object with different status codes and messages depending on the operation's outcome. If any required parameters are missing or an instance or owner cannot be found, it returns a response indicating an error with a message explaining the issue. If the database creation fails, it returns an error message with details about the failure. Upon successful creation, it returns a success status and clears instance resource caches from Redis."
    },
    {
        "file_path": "sql\\instance_database.py",
        "scope": "edit",
        "lineno": 135,
        "summarize": "User Input Sources:  \n- The function takes user input from an HTTP POST request, specifically through `request.POST`. It retrieves the following parameters: `instance_id`, `db_name`, `owner`, and `remark`.\n\nMain Functionality:  \n- The function's main purpose is to edit or record database information based on user input. It checks if the required `db_name` parameter is provided; if not, it returns an error message. It then attempts to retrieve a database instance associated with the user and checks if the specified owner exists. If both checks pass, it updates or creates a record in the `InstanceDatabase` model with the provided information.\n\nOutputs / Return Values:  \n- The function returns a JSON response using `JsonResponse`. The response indicates success or failure through a status code and message. On failure, it provides error messages like \"\u53c2\u6570\u4e0d\u5b8c\u6574\uff0c\u8bf7\u786e\u8ba4\u540e\u63d0\u4ea4\" (Incomplete parameters, please verify and submit) or \"\u4f60\u6240\u5728\u7ec4\u672a\u5173\u8054\u8be5\u5b9e\u4f8b\" (The instance is not associated with your group). On success, it returns a status of 0 with an empty message and data."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "schemasync",
        "lineno": 212,
        "summarize": "User Input Sources:  \nThe function `schemasync` takes input from HTTP POST request parameters. The user can provide the following inputs:\n- `instance_name`: Name of the source database instance.\n- `db_name`: Name of the source database.\n- `target_instance_name`: Name of the target database instance.\n- `target_db_name`: Name of the target database.\n- `sync_auto_inc`: A boolean flag indicating whether to synchronize auto-increment values, expected as a string \"true\" or \"false\".\n- `sync_comments`: A boolean flag indicating whether to synchronize comments, expected as a string \"true\" or \"false\".\n\nMain Functionality:  \nThe core purpose of the `schemasync` function is to compare the schema information between two database instances and optionally synchronize certain attributes such as auto-increment values and comments. It uses a tool or class called `SchemaSync` to perform the schema comparison and synchronization. The function prepares necessary arguments for the schema synchronization process, checks the validity of these arguments, and then executes the schema synchronization command. If the database name is specified as \"all\", it compares all databases by setting the database names to \"*\". The function handles the output of the schema synchronization process, either displaying the results directly or reading the results from generated SQL files for patching and reverting changes.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes:\n- `status`: An integer indicating the success (0) or failure of the operation.\n- `msg`: A message string, typically \"ok\" if successful.\n- `data`: A dictionary containing the output of the schema synchronization process:\n  - `diff_stdout`: The standard output and error messages from the schema synchronization command.\n  - `patch_stdout`: The content of the patch SQL file if a specific database is compared; otherwise, an empty string.\n  - `revert_stdout`: The content of the revert SQL file if a specific database is compared; otherwise, an empty string."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "instance_resource",
        "lineno": 310,
        "summarize": "User Input Sources:  \nThe function takes input from HTTP GET request parameters, specifically: `instance_id`, `instance_name`, `db_name`, `schema_name`, `tb_name`, and `resource_type`. These parameters are accessed via the `request.GET` dictionary, indicating that they are likely provided by the user through a web request.\n\nMain Functionality:  \nThe core purpose of the function is to retrieve resource information from a database instance, such as databases, schemas, tables, or columns, based on the user's request parameters. The function first attempts to identify the database instance using either `instance_id` or `instance_name`. If the instance is found, it uses a query engine to fetch the requested resource type (`database`, `schema`, `table`, or `column`). The function handles different resource types by calling corresponding methods on the query engine to retrieve and possibly filter the data. It includes error handling to manage instances where the instance does not exist or the requested resource type is unsupported.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON includes a `status` indicating success (0) or failure (1), a `msg` for any error messages or a success message, and a `data` field containing the retrieved resource information (or an empty list in case of failure or no data)."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "describe",
        "lineno": 374,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP request, specifically from the POST parameters. The user-provided inputs include `instance_name`, `db_name`, `schema_name`, and `tb_name`. These are extracted from the `request.POST` object.\n\nMain Functionality:  \nThe core purpose of the function is to describe the structure of a database table. It does this by first retrieving a database instance using the `instance_name` provided by the user. If the instance does not exist, it returns an error message. If the instance exists, it then attempts to describe the specified table (`tb_name`) within the given database (`db_name`) and schema (`schema_name`). The function uses a query engine to perform this operation, ensuring that the input strings are escaped to prevent SQL injection. The result of the table description is stored in the `result` dictionary.\n\nOutputs / Return Values:  \nThe function returns a JSON response wrapped in an `HttpResponse` object. The JSON object includes a status code (`status`), a message (`msg`), and data (`data`). If the operation is successful, `status` is 0, `msg` is \"ok\", and `data` contains the table description. If there is an error, `status` is 1, and `msg` contains the error message."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "data_dictionary",
        "lineno": 503,
        "summarize": "User Input Sources:  \nThe function takes a `request` object as input, which typically originates from an HTTP request. This object can contain user-provided data such as query parameters, form data, headers, and cookies.\n\nMain Functionality:  \nThe primary purpose of the function is to render a web page for a data dictionary. It uses the Django `render` function to generate an HTML response. The function is decorated with `@permission_required(\"sql.menu_data_dictionary\", raise_exception=True)`, which ensures that the user has the necessary permissions to access this page. If the user does not have the required permissions, an exception is raised, likely resulting in an HTTP 403 Forbidden response.\n\nOutputs / Return Values:  \nThe function returns an HTTP response that renders the \"data_dictionary.html\" template. The `locals()` function is used to pass local variables to the template context, although in this specific function, no additional local variables are defined. The output is an HTML page that represents the data dictionary."
    },
    {
        "file_path": "sql\\data_dictionary.py",
        "scope": "table_list",
        "lineno": 20,
        "summarize": "User Input Sources:  \nThe function `table_list` takes user input from an HTTP GET request through the `request` object. It specifically retrieves the following parameters from the query string:  \n- `instance_name`\n- `db_name`\n- `db_type`\n\nMain Functionality:  \nThe core purpose of the `table_list` function is to retrieve a list of tables from a specified database instance. It first checks if both `instance_name` and `db_name` are provided. If they are, it attempts to fetch an `Instance` object matching the provided `instance_name` and `db_type`. Upon successfully retrieving the instance, it utilizes a query engine to escape the `db_name` string and retrieve the tables in the specified database. If the instance does not exist, or if any other exception occurs, it returns an error message. If either `instance_name` or `db_name` is missing, it also returns an error message indicating an illegal call.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object has a `status` key (0 for success, 1 for error) and either a `data` key with the list of tables (on success) or a `msg` key with an error message (on failure). The response is encoded in JSON format using a custom JSON encoder (`ExtendJSONEncoder`), with the `bigint_as_string` option set to `True`."
    },
    {
        "file_path": "sql\\data_dictionary.py",
        "scope": "table_info",
        "lineno": 48,
        "summarize": "User Input Sources:  \nThe function `table_info` takes input from an HTTP request object `request`. It retrieves parameters from the query string using `request.GET.get()`. The specific parameters that could originate from the user are `instance_name`, `db_name`, `tb_name`, and `db_type`.\n\nMain Functionality:  \nThe primary purpose of the `table_info` function is to retrieve metadata, description, and index information about a specific database table. It first checks if the required parameters (`instance_name`, `db_name`, and `tb_name`) are provided. If they are, it attempts to retrieve an `Instance` object based on `instance_name` and `db_type`. Then, it uses a query engine associated with the instance to escape the database and table names and fetch the table's metadata, description, and index data. If the database type is MySQL, it also retrieves the SQL statement used to create the table. The function handles exceptions to manage cases where the instance does not exist or other errors occur.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes a status code (`status`), with `0` indicating success and `1` indicating failure, and a `data` field containing the table's metadata, description, index information, and optionally the creation SQL statement for MySQL databases. If an error occurs, the JSON object contains a `msg` field with an error message. The response is set with a content type of `application/json`."
    },
    {
        "file_path": "sql\\data_dictionary.py",
        "scope": "export",
        "lineno": 104,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP request object, specifically from the `GET` parameters `instance_name` and `db_name`. Additionally, it checks the user's permissions and whether the user is a superuser through `request.user`.\n\nMain Functionality:  \nThe function's core purpose is to export a data dictionary for a specified database instance. It first retrieves the instance based on the `instance_name` provided by the user and checks if the user has permission to access it. If the user is not associated with the instance, it returns an error. If a `db_name` is specified, it fetches dictionary information for that specific database; otherwise, it checks if the user is a superuser to potentially export the entire instance's data dictionary. The function generates the data dictionary in HTML format using a template and saves it to a specified directory. If a specific database is being exported, it provides the file for download as an HTTP response.\n\nOutputs / Return Values:  \nThe function primarily returns a JSON response indicating success or failure, with appropriate messages. If exporting a specific database, it returns a `FileResponse` to allow the user to download the generated HTML file containing the data dictionary. If exporting the entire instance's data dictionary, it returns a JSON response with a success message, instructing the user to download the files from the server's `downloads` directory."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "param_list",
        "lineno": 76,
        "summarize": "User Input Sources:  \n- The function takes user input from an HTTP request object (`request`). Specifically, it retrieves data from the POST request parameters:\n  - `instance_id`: This is used to identify the database instance.\n  - `editable`: A boolean flag indicating whether to filter parameters based on their editability.\n  - `search`: A string used to filter parameters by name.\n\nMain Functionality:  \n- The function's core purpose is to generate a list of parameters for a specified database instance. It performs the following steps:\n  1. Retrieves the `instance_id` from the request to find the corresponding database instance. If the instance does not exist, it returns an error message.\n  2. Fetches a list of configured parameters (`cnf_params`) from the `ParamTemplate` model, filtered by the database type and optionally by a search string.\n  3. Retrieves the actual runtime parameters (`ins_variables`) from the database engine associated with the instance.\n  4. Combines the runtime parameters with the configured parameters to create a comprehensive list, marking each parameter's editability.\n  5. Filters the parameters based on the `editable` flag from the request.\n  6. Returns the filtered list of parameters as a JSON response.\n\nOutputs / Return Values:  \n- The function returns a JSON response via `HttpResponse`. The response contains:\n  - An error message and status if the specified instance does not exist.\n  - A list of parameters for the specified instance, with details such as `variable_name`, `runtime_value`, `editable`, and other configuration details if available. The JSON encoding is handled by `ExtendJSONEncoder`, with large integers represented as strings."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "param_history",
        "lineno": 131,
        "summarize": "User Input Sources:  \nThe function `param_history` takes user input from an HTTP POST request. Specifically, it extracts the following parameters from `request.POST`:  \n- `limit`: Used to determine the number of records to retrieve.\n- `offset`: Used to determine the starting point for record retrieval.\n- `instance_id`: Used to filter records by a specific instance.\n- `search`: Optional parameter used to filter records based on a search string.\n\nMain Functionality:  \nThe primary purpose of the `param_history` function is to retrieve a paginated and optionally filtered list of parameter modification histories for a given instance. It filters `ParamHistory` records by `instance_id` and, if provided, further filters by a search term within the `variable_name` field. The function then limits the results based on the `limit` and `offset` parameters to support pagination. It serializes the resulting QuerySet into a list of dictionaries containing specific fields.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes two main components:\n- `total`: The total count of records that match the filters applied.\n- `rows`: A list of dictionaries representing the filtered and paginated parameter modification histories, each containing fields such as `instance__instance_name`, `variable_name`, `old_var`, `new_var`, `user_display`, and `create_time`."
    },
    {
        "file_path": "sql\\instance.py",
        "scope": "param_edit",
        "lineno": 162,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP POST request. Specifically, it retrieves `instance_id`, `variable_name`, and `runtime_value` from the `request.POST` dictionary. These inputs could potentially originate from the user.\n\nMain Functionality:  \n- The primary purpose of the `param_edit` function is to modify a configuration parameter for a given instance. The function first checks if the instance with the provided `instance_id` exists. If not, it returns an error message. Then, it retrieves and sanitizes the `variable_name` and `variable_value`. The function verifies if the parameter template for the `variable_name` exists. It compares the provided `variable_value` with the current runtime value of the parameter. If they are identical, it returns a message indicating no change was made. If they differ, it attempts to update the parameter value using the engine's `set_variable` method. If an error occurs during this process, it returns an error message. If successful, it logs the change in `ParamHistory` and returns a success message.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. This JSON object includes a `status` key (indicating success or failure), a `msg` key (providing a message about the operation's result), and a `data` key (which is an empty list in all cases)."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "query",
        "lineno": 27,
        "summarize": "User Input Sources:  \nThe function takes input from the user through the `request` object, specifically from `request.POST`. The parameters it extracts from the request are `instance_name`, `sql_content`, `db_name`, `tb_name`, `limit_num`, and `schema_name`. Additionally, it utilizes the `request.user` to get information about the user making the request.\n\nMain Functionality:  \nThe function is designed to handle SQL query execution with several security and validation checks. It first verifies user permissions using the `@permission_required` decorator. It then validates the presence of necessary parameters and checks if the user has access to the specified database instance. The function performs SQL query validation to ensure that certain types of queries (e.g., those with a `*` if disabled) are not executed. It also checks user privileges regarding the query and applies limits to the query if necessary. The query is executed, and results are retrieved. If data masking is enabled, it applies masking to the results. The function logs the query execution details and handles any exceptions that occur during processing.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes a status code, a message, and potentially the query result data. If an error occurs, the status code is set to 1, and an error message is included. The response may also contain masked query results if data masking is enabled and successful."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "querylog",
        "lineno": 213,
        "summarize": "User Input Sources:  \nThe function `querylog` takes a single parameter, `request`, which is likely to be an HTTP request object. This implies that the function can receive user input through various HTTP request components such as query parameters, POST data, headers, or cookies.\n\nMain Functionality:  \nThe primary purpose of the `querylog` function is to serve as a wrapper around another function named `_querylog`. It is decorated with `@permission_required(\"sql.menu_sqlquery\", raise_exception=True)`, which indicates that it checks for a specific user permission, `sql.menu_sqlquery`. If the user does not have this permission, an exception is raised, preventing further execution. If the permission check passes, it delegates the request handling to the `_querylog` function.\n\nOutputs / Return Values:  \nThe function returns whatever the `_querylog` function returns. Since the specifics of `_querylog` are not provided, the exact nature of the output is unclear. However, it is likely related to handling or logging SQL queries, given the context provided by the permission string. The output could be an HTML page, JSON object, or other data format typically used in web applications."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "querylog_audit",
        "lineno": 218,
        "summarize": "User Input Sources:  \nThe function `querylog_audit` takes a single parameter, `request`, which is typically an HTTP request object. This object can contain user input through various means such as query parameters, POST data, cookies, or headers.\n\nMain Functionality:  \nThe primary purpose of the `querylog_audit` function is to serve as a wrapper around another function called `_querylog`. It applies a permission check using the `@permission_required` decorator to ensure that the user has the \"sql.audit_user\" permission. If the user lacks this permission, an exception is raised. If the permission check passes, the function delegates the processing to the `_querylog` function by passing the `request` object to it.\n\nOutputs / Return Values:  \nThe function returns whatever the `_querylog` function returns. Without the implementation details of `_querylog`, it is unclear what the specific output is, but it could potentially be an HTML page, JSON object, or any other type of HTTP response."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "favorite",
        "lineno": 294,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP POST request, specifically through the `request.POST` dictionary. The inputs include:\n  - `query_log_id`: An identifier for a query log.\n  - `star`: A string that determines whether the query log is marked as a favorite.\n  - `alias`: An alias for the query log.\n\nMain Functionality:  \n- The function's primary purpose is to mark a query log as a favorite and optionally set an alias for it. It retrieves the `query_log_id`, `star`, and `alias` from the POST request. It then creates or updates a `QueryLog` object with these values, specifically updating the `favorite` and `alias` fields in the database.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. The JSON object indicates a successful operation with a status of `0` and a message of `\"ok\"`. The response is sent with a content type of `application/json`."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "generate_sql",
        "lineno": 320,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP POST request via the `request` object. It retrieves several parameters that could originate from the user:\n  - `query_desc`: A description of the query to be generated.\n  - `db_type`: The type of the database for which the query should be generated.\n  - `instance_name`: The name of the database instance.\n  - `db_name`: The name of the database.\n  - `schema_name`: The name of the database schema.\n  - `tb_name`: The name of the database table.\n\nMain Functionality:  \n- The function aims to generate a SQL query using AI. It first checks if `query_desc` and `db_type` are provided; if not, it returns an error message. It then attempts to retrieve a database instance using the provided `instance_name`. If the instance does not exist, it returns an error message. The function uses the `get_engine` function to obtain a query engine and describes the table structure using the provided database, schema, and table names. It then uses an `OpenaiClient` to generate a SQL query based on the table structure and the user's query description. If the table structure is not available, it generates the SQL query using only the query description and database type.\n\nOutputs / Return Values:  \n- The function returns an HTTP response in JSON format. The JSON object contains:\n  - `status`: An integer indicating the success (0) or failure (1) of the operation.\n  - `msg`: A message string providing additional information or error messages.\n  - `data`: The generated SQL query if successful, or an empty list if not."
    },
    {
        "file_path": "sql\\query.py",
        "scope": "check_openai",
        "lineno": 368,
        "summarize": "User Input Sources: The function takes a `request` parameter, which is typically an HTTP request object. However, in this function, the `request` parameter is not used directly within the function body, so no user input is utilized in the logic.\n\nMain Functionality: The function `check_openai` is designed to verify the existence and validity of an OpenAI configuration. It calls another function, `check_openai_config()`, to perform the actual validation check. If the configuration is not valid (i.e., `check_openai_config()` returns a falsy value), the function prepares an error response indicating that certain necessary configuration elements are missing. These elements include `openai_base_url`, `openai_api_key`, and `default_chat_model`. If the configuration is valid, the function returns a success message.\n\nOutputs / Return Values: The function returns an `HttpResponse` object containing a JSON-encoded message. If the configuration is invalid, the response includes a status of 1, a message indicating missing configuration, and a data value of `False`. If the configuration is valid, the response includes a status of 0, a message of \"ok\", and a data value of `True`."
    },
    {
        "file_path": "sql\\sql_optimize.py",
        "scope": "explain",
        "lineno": 196,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request object, specifically from POST parameters. The user-provided inputs include \"sql_content\", \"instance_name\", and \"db_name\", which are accessed using `request.POST.get()`.\n\nMain Functionality:  \nThe function is designed to process a SQL query optimization request by obtaining the SQL execution plan. It begins by extracting the SQL query, instance name, and database name from the request. It validates these inputs, ensuring that \"sql_content\" and \"instance_name\" are not None. It then attempts to retrieve the specified database instance. The function removes comments from the SQL query, checks for a valid SQL statement, and ensures that the query begins with \"EXPLAIN\". If these checks pass, it executes the SQL query using the specified database instance and returns the execution plan.\n\nOutputs / Return Values:  \nThe function returns a JSON response containing the status, a message, and data. The status indicates success (0) or failure (1), the message provides information about the operation's result, and the data contains the SQL execution plan if successful. The response is returned as an HTTP response with JSON content type."
    },
    {
        "file_path": "sql\\query_privileges.py",
        "scope": "query_priv_apply_list",
        "lineno": 133,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, specifically from `request.POST`. It retrieves the following parameters which could be influenced by the user:\n  - `limit`: Determines the number of records to fetch.\n  - `offset`: Determines the starting point for fetching records.\n  - `search`: A search term used for filtering results.\n\nMain Functionality:  \n- The function is designed to retrieve a list of query privilege applications. It begins by fetching all records from the `QueryPrivilegesApply` model. If a search term is provided, it filters the records to include only those where the title or user display name contains the search term. The function then adjusts the visibility of records based on the user's permissions:\n  - Superusers can see all records.\n  - Users with the \"sql.query_review\" permission can see records associated with their resource groups.\n  - Other users can only see records they submitted themselves.\n- The function limits the number of records returned based on the `limit` and `offset` parameters and orders them by `apply_id` in descending order.\n- The records are serialized into a list of dictionaries for the final output.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. This JSON object includes:\n  - `total`: The total count of records after filtering.\n  - `rows`: A list of dictionaries representing the records, each containing fields like `apply_id`, `title`, `instance__instance_name`, `db_list`, `priv_type`, `table_list`, `limit_num`, `valid_date`, `user_display`, `status`, `create_time`, and `group_name`."
    },
    {
        "file_path": "sql\\query_privileges.py",
        "scope": "user_query_priv",
        "lineno": 314,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object, specifically from `request.POST`. It retrieves several parameters that could originate from the user:\n  - `user_display`: Defaults to \"all\" if not provided.\n  - `limit`: Converted to an integer, used for pagination.\n  - `offset`: Converted to an integer, used for pagination.\n  - `search`: Defaults to an empty string, used for filtering results.\n\nMain Functionality:  \n- The function `user_query_priv` manages query privileges for users. It filters query privileges based on whether they are deleted and their validity date. It supports searching for privileges by user display name, database name, or table name. The function also filters results based on user roles:\n  - Superusers can see all data.\n  - Users with the `sql.query_mgtpriv` permission can see all orders within their resource group.\n  - Regular users can only see their own submitted orders.\n- The function performs pagination on the results based on the `limit` and `offset` values provided by the user.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. This JSON object includes:\n  - `total`: The total count of distinct query privileges matching the criteria.\n  - `rows`: A list of serialized query privileges, including details such as `privilege_id`, `user_display`, `instance_name`, `db_name`, `priv_type`, `table_name`, `limit_num`, and `valid_date`."
    },
    {
        "file_path": "sql\\query_privileges.py",
        "scope": "query_priv_apply",
        "lineno": 192,
        "summarize": "User Input Sources:  \nThe function `query_priv_apply` takes input from an HTTP request object, specifically from POST parameters. The parameters that could originate from the user include:  \n- `title`\n- `instance_name`\n- `group_name`\n- `priv_type`\n- `db_name`\n- `db_list[]`\n- `table_list[]`\n- `valid_date`\n- `limit_num`\n\nMain Functionality:  \nThe primary purpose of the `query_priv_apply` function is to handle requests for applying database query privileges. It performs the following actions:\n1. Extracts necessary information from the request, such as the privilege type and database/table details.\n2. Validates the presence of required parameters based on the privilege type.\n3. Checks if the user already has the requested database or table privileges to prevent duplicate applications.\n4. Creates a new privilege application entry if validation passes.\n5. Initiates an audit process for the application using a transaction to ensure data consistency.\n6. Triggers an asynchronous task to notify relevant parties about the audit.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes:\n- `status`: Indicates the success or failure of the operation (0 for success, 1 for failure).\n- `msg`: A message providing additional information about the operation's result, such as error messages in case of failure.\n- `data`: An empty list, which might be reserved for future use or extensions."
    },
    {
        "file_path": "sql\\query_privileges.py",
        "scope": "query_priv_modify",
        "lineno": 383,
        "summarize": "User Input Sources:  \nThe function `query_priv_modify` takes user input from an HTTP POST request. Specifically, it extracts the following parameters from the request:\n- `privilege_id`: Used to identify which privilege record to modify.\n- `type`: Determines the action to be taken (delete or modify privilege).\n- `valid_date` and `limit_num`: Used when modifying privilege details.\n\nMain Functionality:  \nThe core purpose of the function is to modify or delete a privilege record in a database. It first checks if the privilege exists using the provided `privilege_id`. If the privilege does not exist, it returns an error message. Depending on the `type` parameter:\n- If `type` is 1, it marks the privilege as deleted by setting the `is_deleted` field.\n- If `type` is 2, it updates the privilege's `valid_date` and `limit_num` fields with new values from the request.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object indicating the status of the operation. The JSON object contains:\n- `status`: An integer indicating success (0) or failure (1).\n- `msg`: A message describing the result (\"ok\" for success, or an error message if the privilege does not exist).\n- `data`: An empty list in this implementation, but potentially could hold additional data."
    },
    {
        "file_path": "sql\\query_privileges.py",
        "scope": "query_priv_audit",
        "lineno": 417,
        "summarize": "User Input Sources:  \nThe function `query_priv_audit` takes input from an HTTP request object named `request`. Specifically, it accesses data from `request.POST`, which includes:\n- `apply_id`: Retrieved as an integer from `request.POST[\"apply_id\"]`.\n- `audit_status`: Retrieved as an integer from `request.POST[\"audit_status\"]`.\n- `audit_remark`: Retrieved from `request.POST.get(\"audit_remark\")`, with a default of an empty string if not provided.\n\nMain Functionality:  \nThe core purpose of the `query_priv_audit` function is to handle the auditing of query privileges. It begins by extracting user input from the request to determine the application ID and audit status. It then retrieves the corresponding query privileges application object. The function checks the audit status and remark, and uses a transaction to ensure data consistency during the auditing process. The auditing operation is performed by an `auditor` object, which handles the operation and potential exceptions. If successful, a callback function is invoked to update the database and manage authorization. Finally, the function initiates an asynchronous task to notify relevant parties about the audit status.\n\nOutputs / Return Values:  \nThe function returns an HTTP response. It can render an error page using `render` with an error message if any exceptions occur or if there are issues with the input. If the process completes successfully, it redirects the user to a detailed view of the query application using `HttpResponseRedirect`."
    },
    {
        "file_path": "sql\\binlog.py",
        "scope": "binlog_list",
        "lineno": 26,
        "summarize": "User Input Sources:  \n- The function takes input from the user via an HTTP POST request. Specifically, it retrieves the value associated with the key `\"instance_name\"` from `request.POST`.\n\nMain Functionality:  \n- The function's primary purpose is to retrieve and return a list of binary logs for a specified database instance. It first attempts to find an `Instance` object that matches the `instance_name` provided by the user. If the instance does not exist, it returns an error message. If the instance is found, it uses a query engine to execute the SQL command `\"show binary logs;\"` on the `information_schema`. It processes the query result to format the data into a list of dictionaries, where each dictionary represents a row with column names as keys.\n\nOutputs / Return Values:  \n- The function returns a JSON object wrapped in an HTTP response. The JSON object contains:\n  - A `\"status\"` key indicating success (`0`) or failure (`1`).\n  - A `\"msg\"` key with a success message (\"ok\") or an error message (either \"\u5b9e\u4f8b\u4e0d\u5b58\u5728\" if the instance is not found or the error from the query result).\n  - A `\"data\"` key containing the list of binary log information if successful, or an empty list if the instance does not exist."
    },
    {
        "file_path": "sql\\binlog.py",
        "scope": "my2sql",
        "lineno": 90,
        "summarize": "User Input Sources:  \nThe function `my2sql` takes input from an HTTP POST request. The following parameters are extracted from `request.POST`:  \n- `instance_name`\n- `save_sql`\n- `rollback`\n- `num`\n- `threads`\n- `start_file`\n- `start_pos`\n- `end_file`\n- `end_pos`\n- `stop_time`\n- `start_time`\n- `only_schemas` (as a list)\n- `only_tables[]` (as a list)\n- `sql_type[]` (as a list)\n- `extra_info`\n- `ignore_primary_key`\n- `full_columns`\n- `no_db_prefix`\n- `file_per_table`\n\nMain Functionality:  \nThe `my2sql` function is designed to parse MySQL binary logs using the `my2sql` tool. It extracts various parameters from the HTTP request, prepares them for the `my2sql` command, and executes the command to retrieve SQL statements from the binary logs. The function performs parameter validation, constructs command-line arguments, and executes the command, capturing and processing its output. If specified, it also saves the SQL output asynchronously to a file. The function handles exceptions and logs errors if they occur.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes a `status` field indicating success or failure, a `msg` field with a message, and a `data` field containing the extracted SQL statements as a list of dictionaries. If an error occurs during command execution, the error message is included in the response. If the `save_sql` flag is true, the SQL statements are also saved asynchronously to a file."
    },
    {
        "file_path": "sql\\binlog.py",
        "scope": "del_binlog",
        "lineno": 60,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request. Specifically, it retrieves `instance_id` and `binlog` from the POST data of the request object.\n\nMain Functionality:  \nThe function is designed to delete a specific binary log (binlog) from a database server. It first checks if the provided `instance_id` corresponds to an existing database instance. If the instance does not exist, it returns an error message. If the instance is found and a `binlog` is specified, it uses a query engine to execute a SQL command to purge the specified binlog from the database. The function then checks the result of the SQL query to determine if the operation was successful or if there was an error.\n\nOutputs / Return Values:  \nThe function returns a JSON object wrapped in an HTTP response. This JSON object includes a status code, a message indicating success or failure, and any additional data. The possible status codes are:  \n- `0` for successful deletion of the binlog.\n- `1` for errors related to missing instance or binlog.\n- `2` for errors encountered during the deletion process."
    },
    {
        "file_path": "sql\\slowlog.py",
        "scope": "slowquery_review",
        "lineno": 28,
        "summarize": "User Input Sources:  \nThe function `slowquery_review` takes input from an HTTP POST request. The user inputs include:\n- `instance_name`: Retrieved from `request.POST.get(\"instance_name\")`\n- `StartTime`: Retrieved from `request.POST.get(\"StartTime\")`\n- `EndTime`: Retrieved from `request.POST.get(\"EndTime\")`\n- `db_name`: Retrieved from `request.POST.get(\"db_name\")`\n- `limit`: Retrieved and converted to an integer from `request.POST.get(\"limit\")`\n- `offset`: Retrieved and converted to an integer from `request.POST.get(\"offset\")`\n- `search`: Retrieved from `request.POST.get(\"search\")`\n- `sortName`: Retrieved and converted to a string from `request.POST.get(\"sortName\")`\n- `sortOrder`: Retrieved and converted to a lowercase string from `request.POST.get(\"sortOrder\")`\n\nMain Functionality:  \nThe primary purpose of the `slowquery_review` function is to review slow SQL queries. It performs the following actions:\n1. It checks if the user has the necessary permissions to access the functionality.\n2. It validates if the user has access to the specified database instance.\n3. It determines if the instance is an Aliyun RDS instance or another type of instance.\n   - If it is an Aliyun RDS instance, it uses a specific query engine to fetch slow query data via an API.\n   - If it is another type of instance, it constructs a query to retrieve slow query data from the local database, filtering and sorting it based on user input parameters.\n4. It processes and formats the retrieved data, calculating averages and totals for various metrics related to slow queries.\n5. It prepares the result in a structured format, including the total number of slow queries and a list of detailed slow query records.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes:\n- `status`: Status of the operation (only included in error cases).\n- `msg`: Message describing the result or error (only included in error cases).\n- `data`: An array of detailed slow query records (only included in error cases).\n- `total`: Total count of slow queries retrieved.\n- `rows`: A list of slow query records with detailed metrics such as average query time, total execution counts, total execution times, scanned row counts, and returned row counts."
    },
    {
        "file_path": "sql\\slowlog.py",
        "scope": "slowquery_review_history",
        "lineno": 121,
        "summarize": "User Input Sources:  \nThe function `slowquery_review_history` takes user input from an HTTP POST request. Specifically, it retrieves the following parameters from `request.POST`: `instance_name`, `StartTime`, `EndTime`, `db_name`, `SQLId`, `limit`, `offset`, `search`, `sortName`, and `sortOrder`.\n\nMain Functionality:  \nThe core purpose of the function is to review the history of slow SQL queries. It begins by checking the user's permission to access the slow query menu. The function then validates if the user has access to the specified database instance. Depending on whether the instance is an Alibaba Cloud RDS or another type, the function either calls an external API to fetch slow query logs or queries a local database table for slow query history. It processes the data, including filtering, sorting, and formatting the results, to provide a structured overview of slow query statistics.\n\nOutputs / Return Values:  \nThe function returns a JSON object encapsulated in an `HttpResponse`. This JSON object includes the total count of slow queries and a list of detailed slow query records. Each record contains information such as execution start time, database name, host address, SQL text, execution counts, query time metrics, lock times, and row counts."
    },
    {
        "file_path": "sql\\sql_optimize.py",
        "scope": "optimize_sqladvisor",
        "lineno": 28,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request, specifically from POST parameters. The parameters include `sql_content`, `instance_name`, `db_name`, and `verbose`. These inputs are typically provided by the user through a web form or API request.\n\nMain Functionality:  \nThe function `optimize_sqladvisor` is designed to optimize SQL queries using the SQLAdvisor tool. It begins by validating the presence of required POST parameters (`sql_content` and `instance_name`). It then attempts to retrieve instance information associated with the user and checks if the SQLAdvisor tool's path is configured. If these checks pass, the function prepares a set of arguments needed for SQLAdvisor to analyze the SQL query. The arguments include database connection details and the SQL query itself. It then checks the validity of these arguments, converts them into a command-line format, and executes the SQLAdvisor tool to generate an analysis report. If any step fails, an appropriate error message is returned.\n\nOutputs / Return Values:  \nThe function returns a JSON response encapsulated in an `HttpResponse` object. The JSON object contains a status code (`status`), a message (`msg`), and data (`data`). The `data` field contains the output from the SQLAdvisor tool, which includes the analysis report of the SQL query. In case of errors, the status is set to 1, and an appropriate error message is provided in the `msg` field."
    },
    {
        "file_path": "sql\\sql_optimize.py",
        "scope": "optimize_sqltuning",
        "lineno": 151,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP request object `request`. Specifically, it retrieves:\n  - `instance_name` from `request.POST.get(\"instance_name\")`\n  - `db_name` from `request.POST.get(\"db_name\")`\n  - `sqltext` from `request.POST.get(\"sql_content\")`\n  - `option` from `request.POST.getlist(\"option[]\")`\n\nMain Functionality:  \n- The function is designed to perform SQL tuning operations on a given SQL query. It first formats and splits the SQL query to remove comments and only considers the first statement. It checks if the SQL query is of type `SELECT`, `SHOW`, or `EXPLAIN`; if not, it returns an error message.\n- It verifies if the specified database instance is associated with the user's group. If the instance does not exist for the user, it returns an error message.\n- If the instance is valid, it initializes a `SqlTuning` object with the provided database and SQL details.\n- Based on the options provided in the request, it performs various SQL tuning operations, such as fetching basic information, system parameters, optimizer switch settings, SQL execution plans, object statistics, and executing SQL to get session status.\n- The function then compiles the results of these operations into a dictionary and closes the database connection.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. This JSON object includes:\n  - A `status` key indicating success (0) or failure (1).\n  - A `msg` key with a message about the result.\n  - A `data` key containing various details about the SQL tuning process, such as basic information, system parameters, optimizer switch settings, SQL execution plans, object statistics, session status, and the processed SQL text."
    },
    {
        "file_path": "sql\\sql_optimize.py",
        "scope": "optimize_soar",
        "lineno": 89,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request. The specific parameters it retrieves from the request are `instance_name`, `db_name`, and `sql`. These inputs are obtained using `request.POST.get()` method, indicating they are expected to be part of the form data in the POST request.\n\nMain Functionality:  \nThe primary purpose of the `optimize_soar` function is to optimize SQL queries using the Soar tool. The function first validates that all necessary parameters (`instance_name`, `db_name`, and `sql`) are provided. It then attempts to retrieve a database instance associated with the user and specified instance name. If successful, it constructs connection strings for both the online and test database environments. The function prepares a set of arguments for the Soar tool, checks the validity of these arguments, and then executes the Soar command to analyze the provided SQL query. The analysis results are captured and returned to the client.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes a status code, a message indicating success or failure, and the data (either the analysis report from Soar or error messages). The content type of the response is set to `application/json`."
    },
    {
        "file_path": "sql\\sql_optimize.py",
        "scope": "optimize_sqltuningadvisor",
        "lineno": 247,
        "summarize": "User Input Sources:  \nThe function `optimize_sqltuningadvisor` takes input from an HTTP request object named `request`. It specifically extracts the following parameters from the POST data of the request:\n- `sql_content`: The SQL statement to be analyzed.\n- `instance_name`: The name of the database instance.\n- `db_name`: The schema name.\n\nMain Functionality:  \nThe primary purpose of this function is to generate an optimization report for a given SQL query using a SQL Tuning Advisor tool. It performs the following steps:\n1. Validates that `sql_content` and `instance_name` are provided in the request. If not, it returns an error message indicating missing parameters.\n2. Attempts to retrieve the database instance associated with the `instance_name` for the current user. If the instance does not exist, it returns an error message.\n3. Formats the SQL content to preserve comments and escape single quotes, ensuring it is syntactically correct.\n4. Splits the SQL content to use the first valid SQL statement.\n5. Checks if the database type of the instance is \"oracle\". If not, it returns an error message stating that the SQL Tuning Advisor only supports Oracle databases.\n6. If all checks pass, it uses a query engine to run the SQL Tuning Advisor on the SQL content and retrieve an optimization report.\n7. The optimization report is then included in the response data.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes:\n- `status`: An integer indicating success (0) or failure (1).\n- `msg`: A message providing information about the result or any errors encountered.\n- `data`: A list containing the optimization report if successful; it is empty in case of errors."
    },
    {
        "file_path": "sql\\slowlog.py",
        "scope": "report",
        "lineno": 214,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP GET request parameter named \"checksum\". This input is accessed through `request.GET.get(\"checksum\")`.\n\nMain Functionality:  \nThe function generates a historical trend report for slow SQL queries. It retrieves data related to the frequency and duration of slow queries using the provided checksum to query a database. The function then uses this data to create a line chart visualizing the number of slow queries and their 95th percentile duration over time. The chart is configured with various options, such as smooth lines and area styles, and it is embedded into the response.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON includes a status code, a message, and the HTML content of the rendered chart embedded in the \"data\" field. The response has a content type of \"application/json\"."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "process",
        "lineno": 22,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP POST request. Specifically, it retrieves the values of \"instance_name\" and \"command_type\" from the POST data. Additionally, it collects all other POST parameters into a dictionary named `request_kwargs`, excluding \"command_type\".\n\nMain Functionality:  \nThe function's core purpose is to process a database-related request based on user input. It first attempts to retrieve a database instance associated with the user using the provided \"instance_name\". If the instance is not found, it returns an error message indicating that the user's group is not associated with the instance. If the instance is found, it creates a query engine and executes a process list command using the \"command_type\" and additional parameters from the POST request. The result of this command is then processed to determine if there were any errors and to format the output accordingly.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. The JSON object includes a status code (0 for success, 1 for failure), a message (\"ok\" for success or an error message), and potentially a list of rows representing the process list if the query was successful. The JSON serialization uses a custom encoder, `ExtendJSONEncoderBytes`, for handling specific data types."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "create_kill_session",
        "lineno": 55,
        "summarize": "User Input Sources:  \n- The function receives input from an HTTP request (`request`), specifically from the POST parameters. It extracts `instance_name` and `ThreadIDs` from `request.POST`.\n\nMain Functionality:  \n- The function is designed to construct and return commands for killing database sessions based on the database type. It first verifies if the user has the necessary permissions to kill sessions using the `@permission_required` decorator. It then retrieves the `instance_name` and `ThreadIDs` from the POST request. The function checks if the user has access to the specified database instance. If the instance exists, it determines the type of database (MySQL, MongoDB, Oracle) and generates the appropriate kill command using the `get_kill_command` method of the query engine. If the database type is not supported, it returns an error message.\n\nOutputs / Return Values:  \n- The function returns a JSON object wrapped in an `HttpResponse`. The JSON contains the status of the operation, a message, and the data, which includes the kill command(s) if successful, or an error message if the operation fails or if the database type is unsupported."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "kill_session",
        "lineno": 90,
        "summarize": "User Input Sources:  \nThe function `kill_session` takes user input from an HTTP POST request. Specifically, it retrieves `instance_name` and `ThreadIDs` from the POST data (`request.POST.get(\"instance_name\")` and `request.POST.get(\"ThreadIDs\")`).\n\nMain Functionality:  \nThe core purpose of the `kill_session` function is to terminate database sessions or operations for a given database instance. The function first checks if the user has the necessary permissions (`sql.process_kill`). It then attempts to find a database instance associated with the user's group using the provided `instance_name`. If the instance is found, it initializes a database engine and attempts to kill sessions or operations based on the database type (MySQL, MongoDB, or Oracle). If the database type is unsupported, it returns an error message. The function handles errors during the kill operation and updates the result accordingly.\n\nOutputs / Return Values:  \nThe function returns an HTTP response with a JSON object. This JSON object contains a status code (`status`), a message (`msg`), and additional data (`data`). The status indicates success (0) or failure (1), with corresponding messages and data depending on the outcome of the operation."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "tablespace",
        "lineno": 128,
        "summarize": "User Input Sources:  \n- The function takes user input from an HTTP POST request. Specifically, it retrieves the values for \"instance_name\", \"offset\", and \"limit\" from `request.POST`. These values could originate from user-provided data in a web form or an API request.\n\nMain Functionality:  \n- The function's core purpose is to retrieve tablespace information for a specified database instance. It first checks if the user has the required permissions to view tablespace information. It then attempts to find the database instance associated with the provided \"instance_name\". If the instance is found, it uses a query engine to fetch tablespace information, specifically supporting MySQL and Oracle database types. The function also handles error cases where the instance is not found or the database type is unsupported. The query results are processed, and any errors are captured.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. This JSON object includes the status of the operation, a message, and potentially the tablespace data. The data structure includes the status code, a message indicating success or the nature of any error, the rows of tablespace information (if successful), and the total count of tablespace entries."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "trxandlocks",
        "lineno": 168,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP POST request, specifically retrieving the value of \"instance_name\" from the request's POST data.\n\nMain Functionality:  \n- The function is designed to handle HTTP requests to view transaction and lock information for a database instance. It first checks if the user has the necessary permission to view this information. Then, it attempts to retrieve a database instance associated with the user using the provided \"instance_name\". If the instance is not found, it returns an error message. If the instance is found, it determines the type of database (MySQL or Oracle) and retrieves transaction and lock information using the appropriate query engine method. If the database type is not supported, it returns an error message.\n\nOutputs / Return Values:  \n- The function returns an HTTP response containing a JSON object. The JSON object includes a status code, a message, and possibly data about transactions and locks if the query is successful. If there is an error, it includes an error message instead of data."
    },
    {
        "file_path": "sql\\db_diagnostic.py",
        "scope": "innodb_trx",
        "lineno": 205,
        "summarize": "User Input Sources:  \n- The function takes user input from an HTTP request object, specifically from the POST data using `request.POST.get(\"instance_name\")`. This input is expected to be the name of a database instance.\n\nMain Functionality:  \n- The primary purpose of the `innodb_trx` function is to retrieve and return information about long transactions from a specified database instance, specifically for MySQL databases. It first checks if the user has permission to view transaction information and then attempts to retrieve the instance based on the provided `instance_name`. If the instance is found and is of type \"mysql\", it uses a query engine to fetch long transaction details. If the instance type is not supported or if there is an error in fetching the data, appropriate error messages are returned.\n\nOutputs / Return Values:  \n- The function returns a JSON object wrapped in an `HttpResponse`. The JSON object contains the status of the operation, a message, and potentially the data (in the form of a list of transactions) if the query is successful. If there is an error or unsupported database type, it returns an error message and an empty data list."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_list",
        "lineno": 40,
        "summarize": "User Input Sources:  \nThe function `archive_list` takes user input through the `request` object, which is typical in Django views. Specifically, it extracts the following parameters from `request.GET` (query parameters of an HTTP request):\n- `filter_instance_id`: Used to filter records by a specific instance ID.\n- `state`: Used to filter records based on their state (expected to be \"true\" or \"false\").\n- `limit`: Used to determine the number of records to return.\n- `offset`: Used to determine the starting point for records to return.\n- `search`: Used for filtering records based on a search query.\n\nMain Functionality:  \nThe primary purpose of the `archive_list` function is to retrieve and return a list of archived application records based on certain filtering and access control criteria. It does this by:\n1. Checking the user's permissions to determine the level of access to the records.\n2. Constructing a filter dictionary based on the provided query parameters and the user's permissions.\n3. Filtering the `ArchiveConfig` model objects according to the constructed filter dictionary and the search term, if provided.\n4. Counting the total number of filtered records.\n5. Ordering and slicing the filtered records based on `offset` and `limit` parameters.\n6. Serializing the resulting queryset into a list of dictionaries.\n7. Returning the data as a JSON response, including the total count and the list of records.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes:\n- `total`: The total count of records that match the filtering criteria.\n- `rows`: A list of dictionaries, each representing an archived application record with fields such as `id`, `title`, `src_instance__instance_name`, `src_db_name`, `src_table_name`, `dest_instance__instance_name`, `dest_db_name`, `dest_table_name`, `sleep`, `mode`, `no_delete`, `status`, `state`, `user_display`, `create_time`, and `resource_group__group_name`."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_apply",
        "lineno": 117,
        "summarize": "User Input Sources:  \nThe function takes user input from an HTTP POST request, specifically from the `request.POST` dictionary. The parameters that can originate from user input include:\n- `title`\n- `group_name`\n- `src_instance_name`\n- `src_db_name`\n- `src_table_name`\n- `mode`\n- `dest_instance_name`\n- `dest_db_name`\n- `dest_table_name`\n- `condition`\n- `no_delete`\n- `sleep`\n\nMain Functionality:  \nThe function `archive_apply` handles a request to archive instance data. It performs the following tasks:\n1. Retrieves and validates user input from the POST request.\n2. Checks if the required parameters are provided and returns an error message if they are incomplete.\n3. Validates the source instance information and ensures that the user's group is associated with the specified source instance.\n4. If the mode is \"dest\", it also validates the destination instance information.\n5. Retrieves the resource group information based on the provided group name.\n6. Uses a database transaction to save the archive request information into the database.\n7. Initiates an audit process for the request and handles potential exceptions.\n8. Depending on the audit status, updates the workflow state and saves it.\n9. Asynchronously notifies about the audit process.\n\nOutputs / Return Values:  \nThe function returns a JSON response (`JsonResponse`) that includes:\n- A status code indicating success (`0`) or failure (`1`).\n- A message that describes the result of the operation.\n- Data containing information about the workflow status, audit ID, and archive ID if successful."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_audit",
        "lineno": 237,
        "summarize": "User Input Sources:  \nThe function `archive_audit` takes user input from an HTTP request object named `request`. Specifically, it extracts values from the POST data of the request:\n- `archive_id`: An integer value obtained from `request.POST[\"archive_id\"]`.\n- `audit_status`: An integer value parsed from `request.POST[\"audit_status\"]`.\n- `audit_remark`: An optional string obtained from `request.POST.get(\"audit_remark\")`.\n\nMain Functionality:  \nThe core purpose of the `archive_audit` function is to review and process a data archive application. It performs the following steps:\n1. Retrieves and validates user input from the POST request.\n2. Attempts to retrieve an `ArchiveConfig` object using the `archive_id`. If it doesn't exist, an error page is rendered.\n3. Determines the appropriate auditor for the workflow using the resource group associated with the archive workflow.\n4. Utilizes a database transaction to ensure data consistency while performing the audit operation.\n5. Updates the workflow's status based on the audit result.\n6. Asynchronously triggers a notification task related to the audit process.\n\nOutputs / Return Values:  \nThe function can return several types of responses:\n- An error HTML page rendered with an error message if there is a problem with input data, the audit process, or if the archive workflow does not exist.\n- An HTTP redirect to a URL for viewing archive details (`sql:archive_detail`) if the audit operation completes successfully."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_switch",
        "lineno": 515,
        "summarize": "User Input Sources:  \nThe function takes input from an HTTP request object, specifically from the POST data. It expects two parameters: \"archive_id\" and \"state\", which are retrieved using `request.POST.get()`.\n\nMain Functionality:  \nThe core purpose of the function is to toggle the state of an archive task. It does this by updating the \"state\" field of an `ArchiveConfig` object, identified by `archive_id`, with the value derived from the \"state\" parameter. If the \"state\" parameter is \"true\", the archive is enabled; otherwise, it is disabled. The function is decorated with `@permission_required`, ensuring that only users with the \"sql.archive_mgt\" permission can execute it.\n\nOutputs / Return Values:  \nThe function returns a JSON response. If the update is successful, it returns a JSON object with a status of 0 and a message \"ok\". If an exception occurs during the update, it returns a JSON object with a status of 1 and includes the exception message in the \"msg\" field."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_once",
        "lineno": 528,
        "summarize": "User Input Sources:  \nThe function `archive_once` takes user input from an HTTP request object, specifically from the query parameters. It retrieves the value of `archive_id` using `request.GET.get(\"archive_id\")`.\n\nMain Functionality:  \nThe core purpose of the `archive_once` function is to initiate an asynchronous archiving task. It uses the `async_task` function to schedule the task named `\"sql.archiver.archive\"` with the specified `archive_id`. The task is given a name in the format `archive-{archive_id}` and is set to run without a timeout (indicated by `timeout=-1`).\n\nOutputs / Return Values:  \nThe function returns a JSON response using `JsonResponse`. The response indicates a successful operation with a status code of 0 and a message \"ok\". The data field in the JSON response is an empty dictionary."
    },
    {
        "file_path": "sql\\archiver.py",
        "scope": "archive_log",
        "lineno": 479,
        "summarize": "User Input Sources:  \nThe function `archive_log` takes user input from HTTP request parameters via the `request.GET` object. Specifically, it retrieves the following parameters: `limit`, `offset`, and `archive_id`. These parameters are typically provided by the user as part of a query string in an HTTP GET request.\n\nMain Functionality:  \nThe core purpose of the `archive_log` function is to retrieve and return a list of archive logs from a database. It uses the `archive_id` to filter logs related to a specific archive. The function constructs a query to fetch logs, annotating each log with additional information by concatenating the `cmd` and `statistics` fields. It limits the number of logs retrieved based on the `limit` and `offset` parameters provided by the user, orders the logs by their ID in descending order, and serializes the resulting queryset into a list of dictionaries.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes two keys: `total`, which represents the total number of logs that match the query, and `rows`, which is a list of dictionaries where each dictionary represents an individual log entry with various fields such as `cmd`, `info`, `condition`, `mode`, `no_delete`, `select_cnt`, `insert_cnt`, `delete_cnt`, `success`, `error_info`, `start_time`, and `end_time`. The response is serialized using a custom JSON encoder, `ExtendJSONEncoder`, and is sent with a content type of `application/json`."
    },
    {
        "file_path": "common\\utils\\ding_api.py",
        "scope": "sync_ding_user",
        "lineno": 121,
        "summarize": "User Input Sources:  \nThe function `sync_ding_user` takes a `request` object as input, which is typical in web applications to represent an HTTP request. However, in this function, the `request` object is not directly used or accessed, suggesting that the function's execution does not depend on user-provided data within the request.\n\nMain Functionality:  \nThe primary purpose of the `sync_ding_user` function is to initiate a synchronization process and schedule it to run daily. It does this by calling the `add_sync_ding_user_schedule` function, which is assumed to handle the scheduling and triggering of the synchronization task.\n\nOutputs / Return Values:  \nThe function returns a JSON response using `JsonResponse`. If the synchronization and scheduling are successful, it returns a JSON object with a status code of 0 and a success message. In case of an exception during the process, it returns a JSON object with a status code of 1 and an error message detailing the exception."
    },
    {
        "file_path": "sql\\audit_log.py",
        "scope": "audit_log",
        "lineno": 47,
        "summarize": "User Input Sources:  \nThe function `audit_log` takes user input from an HTTP POST request. It retrieves several parameters from the request object:  \n- `limit` and `offset`: These are used for pagination and are expected to be integers.\n- `search`: A string used for filtering the logs based on user name, action, or extra information.\n- `action`: A string to filter logs by specific actions.\n- `start_date` and `end_date`: Strings representing date ranges for filtering the logs.\n\nMain Functionality:  \nThe core purpose of the `audit_log` function is to retrieve and filter audit logs from a database, based on the specified criteria provided in the HTTP POST request. It applies filters for date ranges, specific actions, and search terms within certain fields of the audit log entries. It then paginates the results based on the `limit` and `offset` values. The function prepares a dictionary with the total count of filtered logs and a list of the log entries.\n\nOutputs / Return Values:  \nThe function returns an HTTP response containing a JSON object. This JSON object includes:\n- `total`: The total number of audit log entries that match the filtering criteria.\n- `rows`: A list of dictionaries, each representing an audit log entry with fields such as `user_id`, `user_name`, `user_display`, `action`, `extra_info`, and `action_time`."
    },
    {
        "file_path": "sql\\audit_log.py",
        "scope": "audit_input",
        "lineno": 25,
        "summarize": "User Input Sources: The function takes input from an HTTP POST request. It specifically retrieves data from the `request.POST` dictionary, which includes user-submitted fields \"action\" and \"extra_info\". Additionally, it accesses user information from the `request.user` object.\n\nMain Functionality: The function's core purpose is to log or audit user actions. It collects user-related information (user ID, username, display name) and the action details submitted via the HTTP POST request. This data is used to create an `AuditEntry` object, which is then saved to a database or logging system. The function is decorated with `@login_required`, ensuring that only authenticated users can access it.\n\nOutputs / Return Values: The function returns an HTTP response containing a JSON object. This JSON object includes the user's ID, username, display name, the action performed, and any additional information provided. The JSON response is generated using a custom JSON encoder, `ExtendJSONEncoder`, and is returned with a content type of \"application/json\"."
    },
    {
        "file_path": "sql\\user.py",
        "scope": "lists",
        "lineno": 10,
        "summarize": "User Input Sources:  \n- The function takes a `request` parameter, which is typically an HTTP request object in a Django application. This object may contain user-related data such as headers, cookies, and other HTTP request information, but in this specific function, the `request` object is not directly used to process user input.\n\nMain Functionality:  \n- The primary purpose of this function is to retrieve a list of users from the database. It queries the `Users` model, ordering the results by the \"username\" field. It then selects specific fields for each user, including \"id\", \"username\", \"display\", \"is_superuser\", \"is_staff\", \"is_active\", and \"email\". The function constructs a list of dictionaries, each representing a user, and packages this list into a JSON response with a status and message.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponse` containing a JSON object. This JSON object includes a status code (`status`), a message (`msg`), and the list of user data (`data`). The response is sent with the content type set to `application/json`."
    },
    {
        "file_path": "common\\twofa\\totp.py",
        "scope": "generate_qrcode",
        "lineno": 74,
        "summarize": "User Input Sources:  \n- The function takes input from the `request` object, which typically originates from an HTTP request. This includes `request.user` and potentially `request.session.get(\"user\")`.\n- The `data` parameter, which serves as the `secret_key`, is another input that could originate from the user, possibly through an HTTP request parameter or body.\n\nMain Functionality:  \n- The function generates a QR code image based on a secret key and user information.\n- It uses the `pyotp.totp.TOTP` class to create a provisioning URI for a Time-based One-Time Password (TOTP) using the provided `secret_key` and the user's username.\n- A QR code is generated from this URI using the `QRCode` class, with specific configurations for version, error correction, box size, and border.\n- The QR code image is then created, saved into a buffer, and prepared for output as an image stream.\n\nOutputs / Return Values:  \n- The function returns an `HttpResponse` containing the QR code image stream with a content type of \"image/png\".\n- In case of an exception, it logs the error but does not return any specific output."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqlexportworkflow",
        "lineno": 162,
        "summarize": "User Input Sources:  \n- The function takes `request` as an input parameter, which could originate from the user, typically in the context of a web application. The `request` object may contain information such as the logged-in user and any HTTP request parameters.\n\nMain Functionality:  \n- The function is designed to render a web page that displays a list of SQL export workflows. It begins by determining the current user's permissions and configuring access controls based on whether the user is a superuser or has specific permissions. The function constructs a filter dictionary to determine which SQL workflows the user is allowed to view. If the user is an administrator or has audit permissions, they can view all workflows. Users with specific review or execution permissions can view workflows within their resource groups. All other users can only view workflows they submitted. The function then queries the database for instances and resource groups related to the filtered workflows.\n\nOutputs / Return Values:  \n- The function returns an HTML page rendered using the `render` function. This page, `sqlexportworkflow.html`, is populated with several context variables, including a list of status choices, instances, resource groups, the storage type configuration, and a boolean indicating whether the user can download offline."
    },
    {
        "file_path": "sql\\views.py",
        "scope": "sqlexportsubmit",
        "lineno": 730,
        "summarize": "User Input Sources:  \n- The function takes an HTTP request object as input, which could originate from the user. This request object is used to access the user's details, such as `request.user` and `user.username`.\n\nMain Functionality:  \n- The function `sqlexportsubmit` is responsible for preparing the context needed to render a SQL export submission page. It ensures that certain tags are created if they do not already exist. It retrieves user-specific data such as group memberships and favorite queries. It also checks user permissions to determine whether the user can download or offline download queries. The function then compiles this information into a context dictionary for rendering the appropriate HTML template.\n\nOutputs / Return Values:  \n- The function returns an HTTP response that renders the \"sqlexportsubmit.html\" template. The context provided to the template includes user-specific data such as favorite queries, permissions, and configuration settings, allowing the template to display a personalized SQL export submission page."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "UserList",
        "lineno": 32,
        "summarize": "User Input Sources: \n- The `get` method does not directly take user input, but it utilizes filters and pagination that may be influenced by query parameters in the HTTP request.\n- The `post` method takes input from the HTTP request body in JSON format to create a new user. This input is processed through the `UserSerializer`.\n\nMain Functionality:\n- The `get` method is designed to retrieve and list users from the database. It supports filtering and pagination, allowing for a refined and limited set of results to be returned based on query parameters.\n- The `post` method is responsible for creating a new user. It validates the input data using the `UserSerializer`, and if the data is valid, it saves the new user to the database.\n\nOutputs / Return Values:\n- The `get` method returns a paginated JSON response containing user data. The response is structured as a dictionary with a key `\"data\"` holding the serialized user information.\n- The `post` method returns a JSON response. If user creation is successful, it returns the serialized user data with a status of 201 (Created). If validation fails, it returns the error details with a status of 400 (Bad Request)."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "UserDetail",
        "lineno": 69,
        "summarize": "User Input Sources: \n- The `put` method takes input from the user through `request.data`, which is typically derived from an HTTP PUT request. This data is used to update user details.\n- The `delete` method uses the `pk` parameter from the URL, which is provided by the user to identify which user record to delete.\n\nMain Functionality: \n- The `UserDetail` class is a Django Rest Framework API view designed to handle operations on user data.\n- The `get_object` method retrieves a user object from the database using a primary key (`pk`). If the user does not exist, it raises an `Http404` exception.\n- The `put` method updates an existing user's details. It uses a serializer to validate the input data and save changes to the database if the data is valid.\n- The `delete` method removes a user record from the database based on the provided primary key.\n\nOutputs / Return Values: \n- The `put` method returns a `Response` object containing the serialized user data if the update is successful, or error details with a 400 status code if validation fails.\n- The `delete` method returns a `Response` object with a 204 status code, indicating successful deletion without any content in the response."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "GroupList",
        "lineno": 103,
        "summarize": "User Input Sources: \n- `get` method: This method does not directly take user input but may involve HTTP query parameters for filtering and pagination, as it uses `filter_queryset` and `paginate_queryset`.\n- `post` method: Takes user input from the HTTP request body (`request.data`) to create a new group.\n\nMain Functionality: \n- `get` method: This method retrieves a list of user groups from the database, applies any necessary filtering and pagination, serializes the data using `GroupSerializer`, and returns a paginated response containing the serialized group data.\n- `post` method: This method handles the creation of a new user group. It validates the incoming data using `GroupSerializer`, saves the new group to the database if valid, and returns the serialized data of the newly created group. If the data is invalid, it returns the validation errors.\n\nOutputs / Return Values: \n- `get` method: Returns a paginated JSON response containing serialized group data.\n- `post` method: Returns a JSON response with the serialized data of the newly created group and an HTTP status code 201 if successful, or a JSON response with validation errors and an HTTP status code 400 if the data is invalid."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "GroupDetail",
        "lineno": 139,
        "summarize": "User Input Sources:  \n- The class methods `put` and `delete` take user input through HTTP request parameters. Specifically, the `pk` parameter is used to identify the group object, and `request.data` in the `put` method is used for updating the group details. These inputs typically come from HTTP request paths and bodies.\n\nMain Functionality:  \n- The `GroupDetail` class is a Django REST framework API view designed to handle operations on user groups.  \n  - The `get_object` method retrieves a specific group from the database using the primary key (`pk`). If the group does not exist, it raises an `Http404` exception.\n  - The `put` method updates an existing user group. It retrieves the group using `get_object`, then uses the `GroupSerializer` to validate and save the updated data from the request. If the data is valid, it updates the group and returns the serialized data. If not, it returns validation errors.\n  - The `delete` method deletes a user group identified by the `pk`. It uses `get_object` to retrieve the group and then deletes it from the database.\n\nOutputs / Return Values:  \n- The `put` method returns a JSON object representing the updated group if the update is successful. If the validation fails, it returns a JSON object containing the validation errors with an HTTP 400 status code.\n- The `delete` method returns an HTTP 204 No Content status code to indicate successful deletion of the group without returning any content."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "ResourceGroupList",
        "lineno": 173,
        "summarize": "User Input Sources:  \n- `get` method: Takes input from HTTP GET request parameters, potentially including query parameters for filtering and pagination.\n- `post` method: Takes input from HTTP POST request body, which is expected to be JSON data representing a new resource group.\n\nMain Functionality:  \n- The `get` method: Retrieves and lists all resource groups, potentially filtered and paginated according to the request parameters. It utilizes Django's queryset filtering and pagination mechanisms to manage the data returned.\n- The `post` method: Handles the creation of a new resource group. It validates the input data using the `ResourceGroupSerializer`. If the data is valid, a new resource group is saved to the database.\n\nOutputs / Return Values:  \n- `get` method: Returns a paginated JSON response containing the serialized data of resource groups.\n- `post` method: Returns a JSON response. If the resource group is successfully created, it returns the serialized data of the newly created group with a 201 HTTP status code. If there are validation errors, it returns the error details with a 400 HTTP status code."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "ResourceGroupDetail",
        "lineno": 209,
        "summarize": "User Input Sources:  \n- The `put` and `delete` methods take input from HTTP requests. Specifically, the `put` method uses data from `request.data`, which can originate from user-provided HTTP request bodies. The `pk` parameter in both methods is likely derived from the URL path, which can also be considered user input.\n\nMain Functionality:  \n- The `ResourceGroupDetail` class is a Django REST Framework API view for handling operations on a resource group.  \n- The `get_object` method retrieves a `ResourceGroup` instance by its primary key (`pk`). If the object does not exist, it raises an `Http404` exception.  \n- The `put` method updates an existing resource group. It retrieves the group using `get_object`, validates the input data using `ResourceGroupSerializer`, and updates the resource group if the data is valid. If the validation fails, it returns an error response.  \n- The `delete` method deletes a resource group. It retrieves the group using `get_object` and deletes it from the database.\n\nOutputs / Return Values:  \n- The `put` method returns a JSON object representing the updated resource group if the update is successful. If the validation fails, it returns a JSON object containing error details with a 400 status code.  \n- The `delete` method returns an HTTP response with a 204 No Content status, indicating that the resource was successfully deleted and no content is returned."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "UserAuth",
        "lineno": 243,
        "summarize": "User Input Sources:  \nThe `post` method of the `UserAuth` class takes input from the user through HTTP request data. Specifically, it expects `engineer` and `password` fields to be provided in the request body, which are typically sent by the user when attempting to authenticate.\n\nMain Functionality:  \nThe core purpose of the `UserAuth` class's `post` method is to authenticate a user based on the provided credentials. It first validates the input data using the `UserAuthSerializer`. If the data is valid, it attempts to authenticate the user using the `authenticate` function with the given `engineer` (username) and `password`. If authentication is successful, it returns a success message; otherwise, it returns an error message indicating incorrect username or password.\n\nOutputs / Return Values:  \nThe method returns a JSON response. If the authentication is successful, it returns a JSON object with a status of 0 and a message indicating successful authentication. If the authentication fails, it returns a JSON object with a status of 1 and an error message indicating incorrect username or password. If the input data validation fails, it returns the validation errors with a status of 400 (Bad Request)."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "TwoFA",
        "lineno": 270,
        "summarize": "User Input Sources:  \n- The function takes input from an HTTP POST request through the `request` parameter.\n- The user inputs include `engineer`, `enable`, `auth_type`, and optionally `phone`, which are extracted from `request.data`.\n- The session data is accessed using `request.session.get(\"user\")` to verify the authenticated user.\n\nMain Functionality:  \n- The function is designed to configure two-factor authentication (2FA) for a user. \n- It first validates the input data using the `TwoFASerializer`.\n- It retrieves the user object based on the `engineer` username.\n- It checks if the user is authenticated and matches the session user.\n- Depending on the `enable` flag and `auth_type`, it either enables or disables 2FA:\n  - If `auth_type` is \"totp\", it generates a secret key.\n  - If `auth_type` is \"sms\", it sends an SMS with a one-time password (OTP) and stores it in a Redis database with a 5-minute expiry.\n  - Otherwise, it simply enables or disables 2FA.\n\nOutputs / Return Values:  \n- Returns a JSON response using Django's `Response` class.\n- On input validation failure, it returns validation errors with a 400 status code.\n- It returns a JSON object containing the status and a message if the user authentication fails.\n- On successful execution, it returns the result of the 2FA configuration process, which varies depending on the 2FA type and action performed."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "TwoFAState",
        "lineno": 320,
        "summarize": "User Input Sources:  \nThe function takes input from the user through an HTTP POST request. The user input is provided in the request body, specifically in the form of JSON data. The input is processed using the `TwoFAStateSerializer` which validates the data. The critical piece of user input is the \"engineer\" field, which is used to query the database.\n\nMain Functionality:  \nThe primary purpose of this method is to check and return the two-factor authentication (2FA) configuration status for a specified user. It first validates the input data using a serializer. If the data is valid, it retrieves the user based on the provided \"engineer\" username and checks the user's 2FA configuration. The method then determines if Time-based One-Time Password (TOTP) and SMS-based 2FA methods are enabled or disabled for the user by querying the `TwoFactorAuthConfig` model.\n\nOutputs / Return Values:  \nThe function returns a JSON response. If the input data is invalid, it returns a JSON object containing the validation errors with an HTTP 400 status code. If the input is valid, it returns a JSON object with the status of the TOTP and SMS 2FA configurations (either \"enabled\" or \"disabled\") for the specified user, along with a status code of 0 and a message \"ok\"."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "TwoFASave",
        "lineno": 352,
        "summarize": "User Input Sources: The function takes user input from an HTTP POST request. The input data is accessed via `request.data`, which is expected to include parameters such as `engineer`, `auth_type`, `key`, and `phone`.\n\nMain Functionality: The `post` method of the `TwoFASave` class is designed to save a 2FA (Two-Factor Authentication) configuration using TOTP (Time-based One-Time Password). It first validates the input data using the `TwoFASaveSerializer`. If the data is valid, it retrieves the user associated with the `engineer` username. Based on the `auth_type` provided, it uses an authenticator object to save either a phone number or a key, depending on whether the authentication type is \"sms\" or another type, respectively.\n\nOutputs / Return Values: The function returns an HTTP response. If the input data is invalid, it returns a response with error details and a status code of 400 (Bad Request). If the operation is successful, it returns the result of the `save` method of the authenticator, which is likely a success message or confirmation, encapsulated in a standard HTTP response."
    },
    {
        "file_path": "sql_api\\api_user.py",
        "scope": "TwoFAVerify",
        "lineno": 383,
        "summarize": "User Input Sources:  \nThe `post` method of the `TwoFAVerify` class takes user input from an HTTP POST request. Specifically, it expects data in the form of a JSON object, which includes fields such as \"engineer\", \"otp\", \"key\", \"phone\", and \"auth_type\". These inputs are accessed via `request.data`. Additionally, the method uses `request.session` to retrieve session information, particularly the \"user\" key.\n\nMain Functionality:  \nThe core purpose of the `TwoFAVerify` class is to verify a Two-Factor Authentication (2FA) code for a user. It first validates the input data using the `TwoFAVerifySerializer`. If the data is invalid, it returns an error response. The method checks if the user is authenticated and verifies the 2FA code using an appropriate authenticator based on the `auth_type`. If the user is not authenticated and the session user does not match the input engineer, it returns an error. The method also ensures that the user has 2FA configured, requiring a key if not. If the verification is successful and the user is not already authenticated, the method logs the user in and updates the session expiry. It may also update the user's DingTalk ID under certain conditions.\n\nOutputs / Return Values:  \nThe method returns a JSON response. If there are validation errors, it returns the serializer errors with a status of HTTP 400 Bad Request. If there are logical errors (e.g., mismatched users, missing 2FA configuration), it returns a JSON object with a status code and message describing the error. Upon successful 2FA verification, it returns the result of the verification, which includes a status indicating success or failure."
    },
    {
        "file_path": "sql_api\\api_instance.py",
        "scope": "InstanceList",
        "lineno": 21,
        "summarize": "User Input Sources: \n- `get` method: The user input could originate from HTTP GET request parameters, which may be used for filtering and pagination.\n- `post` method: The user input comes from the HTTP POST request body, which is expected to be a JSON object conforming to the `InstanceSerializer`.\n\nMain Functionality: \n- `get` method: This method retrieves and lists instances from the database. It applies filtering and pagination to the queryset of instances and serializes the paginated results. The method is intended to provide a paginated list of instances based on the applied filters.\n- `post` method: This method is responsible for creating a new instance configuration. It validates the input data against the `InstanceSerializer`, and if the data is valid, it saves a new instance to the database.\n\nOutputs / Return Values: \n- `get` method: Returns a paginated JSON response containing a list of instances, structured as a dictionary with a \"data\" key holding the serialized instance data.\n- `post` method: Returns a JSON response. If the creation is successful, it returns the serialized data of the created instance with a 201 Created status. If the input data is invalid, it returns the validation errors with a 400 Bad Request status."
    },
    {
        "file_path": "sql_api\\api_instance.py",
        "scope": "InstanceDetail",
        "lineno": 58,
        "summarize": "User Input Sources:  \n- The `put` method takes user input from the HTTP request body (`request.data`) and the URL path parameter (`pk`). The body data is expected to be in a format that matches the `InstanceDetailSerializer`.\n- The `delete` method takes user input from the URL path parameter (`pk`).\n\nMain Functionality:  \n- The `get_object` method retrieves an instance of the `Instance` model using the primary key (`pk`). If the instance does not exist, it raises an `Http404` exception.\n- The `put` method updates an existing instance of the `Instance` model. It uses the `InstanceDetailSerializer` to validate and deserialize the input data from the request. If the data is valid, it updates the instance and returns the updated data; otherwise, it returns validation errors.\n- The `delete` method deletes an existing instance of the `Instance` model identified by the primary key (`pk`).\n\nOutputs / Return Values:  \n- The `put` method returns a JSON object containing the updated instance data if the update is successful, or a JSON object containing error messages if validation fails. It returns HTTP status 200 on success and 400 on validation failure.\n- The `delete` method returns an HTTP response with no content and a status code of 204, indicating successful deletion of the instance."
    },
    {
        "file_path": "sql_api\\api_instance.py",
        "scope": "InstanceResource",
        "lineno": 164,
        "summarize": "User Input Sources:  \nThe function receives input from the user through an HTTP POST request. The data from the request is expected to be serialized using `InstanceResourceSerializer`. The specific user inputs include:\n- `instance_id`: The identifier of the instance.\n- `resource_type`: The type of resource being queried (e.g., database, schema, table, column).\n- `db_name`: (Optional) The name of the database.\n- `schema_name`: (Optional) The name of the schema.\n- `tb_name`: (Optional) The name of the table.\n\nMain Functionality:  \nThe primary purpose of the `post` method is to retrieve resource information from a specified instance based on the user's input. It validates the input data using a serializer and then retrieves the corresponding instance from the database. Depending on the `resource_type` specified, it performs one of the following actions:\n- Retrieves all databases in the instance and filters them according to specific regex patterns.\n- Retrieves all schemas in a specified database.\n- Retrieves all tables in a specified database and schema.\n- Retrieves all columns in a specified database, table, and schema.\n\nThe function uses a query engine to escape strings and perform the necessary queries to gather the resource information.\n\nOutputs / Return Values:  \nThe function returns a JSON response containing the resource information. If successful, the response includes a count of the resources and a list of the resource details. If there is an error during processing or validation, the function returns an error message encapsulated in a JSON response with the appropriate HTTP status code."
    },
    {
        "file_path": "sql_api\\api_instance.py",
        "scope": "TunnelList",
        "lineno": 92,
        "summarize": "User Input Sources:\n- The `get` method potentially takes user input through query parameters in the HTTP request, which could be used for filtering and pagination of the queryset.\n- The `post` method takes user input through the HTTP request body, which is expected to be a JSON object representing a new tunnel configuration.\n\nMain Functionality:\n- The `TunnelList` class is a Django REST framework view that provides two main functionalities:\n  - The `get` method lists all existing tunnel configurations, supporting filtering and pagination. It retrieves the tunnel data, applies any necessary filtering and pagination, serializes the data, and returns it in the response.\n  - The `post` method creates a new tunnel configuration. It validates the input data against the `TunnelSerializer`, and if valid, saves the new tunnel configuration to the database.\n\nOutputs / Return Values:\n- The `get` method returns a paginated JSON response containing a list of tunnel configurations. The structure of the JSON response is defined by the `TunnelSerializer`.\n- The `post` method returns a JSON response. If the creation is successful, it returns the created tunnel configuration data with a 201 HTTP status code. If there are validation errors, it returns the errors with a 400 HTTP status code."
    },
    {
        "file_path": "sql_api\\api_instance.py",
        "scope": "AliyunRdsList",
        "lineno": 128,
        "summarize": "User Input Sources: \n- The `get` method takes input from the user through HTTP GET request parameters, which may include filters for the queryset.\n- The `post` method takes user input from HTTP POST request data, specifically expecting data that matches the `AliyunRdsSerializer` schema.\n\nMain Functionality: \n- The `AliyunRdsList` class is a Django Rest Framework view that handles listing and creating configurations for Aliyun RDS instances.\n- The `get` method is designed to list all Aliyun RDS configurations. It applies any provided filters to the queryset, paginates the results, serializes them, and returns the paginated data.\n- The `post` method is responsible for creating a new Aliyun RDS configuration. It validates the incoming data against the `AliyunRdsSerializer`. If the data is valid, it saves the new configuration and returns the serialized data of the newly created object.\n\nOutputs / Return Values:\n- The `get` method returns a paginated JSON response containing the serialized data of the Aliyun RDS configurations.\n- The `post` method returns a JSON response with the serialized data of the newly created configuration if successful, or a JSON object with error messages if the data is invalid. The response status is 201 for successful creation and 400 for invalid data."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "WorkflowList",
        "lineno": 79,
        "summarize": "User Input Sources:\n- The class handles HTTP requests, which can include user input.\n- The `get` method processes input via `request`, which may contain query parameters for filtering.\n- The `post` method takes input from `request.data`, which is expected to be serialized data representing a new workflow.\n\nMain Functionality:\n- The `WorkflowList` class is a Django REST Framework view that manages SQL workflows.\n- It lists existing workflows or allows the submission of new workflows.\n- The `get_queryset` method determines the workflows a user can view based on their permissions. Superusers and users with specific permissions can view all workflows, while others are limited to their own submissions.\n- The `get` method returns a paginated list of workflows, filtered according to the user's permissions.\n- The `post` method allows users to submit a new SQL workflow, validates the input, saves it, and potentially triggers an asynchronous notification task if certain conditions are met.\n\nOutputs / Return Values:\n- The `get` method returns a paginated JSON response containing serialized workflow data.\n- The `post` method returns a JSON response with the serialized data of the newly created workflow and an HTTP status code of 201 (Created)."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "ExecuteCheck",
        "lineno": 49,
        "summarize": "User Input Sources:  \nThe `post` method of the `ExecuteCheck` class takes input from the user via an HTTP POST request. The user inputs are expected to be in JSON format and are accessed through `request.data`. Specifically, it expects parameters like `db_name` and `full_sql` to be provided by the user.\n\nMain Functionality:  \nThe primary purpose of the `ExecuteCheck` class is to perform a syntax check on a provided SQL statement. The process begins with validating the user input using the `ExecuteCheckSerializer`. Once validated, it retrieves an instance from the serializer and uses it to get a database engine through the `get_engine` function. The method then performs SQL syntax checking using the `execute_check` method of the database engine, passing the `db_name` and the SQL statement (`full_sql`) as parameters. The SQL syntax check results are then converted to a dictionary format.\n\nOutputs / Return Values:  \nThe method returns a JSON response containing the results of the SQL syntax check. The results are serialized using the `ExecuteCheckResultSerializer`, which structures the output data before it is sent back to the client. If an exception occurs during the process, an error message is returned as part of a validation error response."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "AuditWorkflow",
        "lineno": 212,
        "summarize": "User Input Sources:  \n- The function `post` takes input from an HTTP request. Specifically, it uses `request.data` to obtain the data sent by the user in the request body. This input is expected to be serialized using `AuditWorkflowSerializer`.\n\nMain Functionality:  \n- The core purpose of the `post` method in the `AuditWorkflow` class is to handle the auditing of workflows. It processes audit requests to either pass or cancel a workflow. The method first validates the input data using `AuditWorkflowSerializer`. It retrieves the relevant `WorkflowAudit` object based on the workflow ID and type provided in the request. Depending on the `audit_type` (\"pass\" or \"cancel\"), it performs actions to either pass or abort the workflow. If the action is successful, it updates the status of the original workflow and sends notifications if configured to do so.\n\nOutputs / Return Values:  \n- The function returns an HTTP response. If the input data is invalid, it returns a 400 Bad Request response with error details. If the operation is successful, it returns a response with a message indicating the success of the operation (either \"passed\" or \"canceled\"). If there are any operation errors, it raises a validation error with a descriptive message."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "WorkflowAuditList",
        "lineno": 161,
        "summarize": "User Input Sources: \n- The class `WorkflowAuditList` has a `post` method that takes input from an HTTP POST request. The user input is accessed via `request.data`, which is expected to contain at least a key named \"engineer\" to identify the user whose audits are to be listed.\n\nMain Functionality:\n- The primary purpose of the `WorkflowAuditList` class is to list pending workflow audits for a specific user. It utilizes a filter set, pagination, and serialization to process and return the data.\n- The `get` method is overridden to return a response indicating that the GET method is not allowed.\n- The `post` method validates the input data using `WorkflowAuditSerializer`. If the data is valid, it retrieves the user's associated resource groups and permission groups. It then filters the `queryset` of workflow audits based on the user's group memberships and the audits' current status. The filtered audits are paginated and serialized before being returned in the response.\n\nOutputs / Return Values:\n- For a valid POST request, the method returns a paginated JSON response containing the serialized data of the pending audits.\n- If the input data is invalid, the method returns a JSON response with the validation errors and a 400 HTTP status code. \n- The `get` method returns a JSON response with a detail message indicating that the GET method is not allowed."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "ExecuteWorkflow",
        "lineno": 302,
        "summarize": "User Input Sources:  \n- The function receives user input from an HTTP POST request, which is encapsulated in the `request` object. Specifically, it utilizes data from `request.data`, which includes parameters such as `workflow_type`, `workflow_id`, `mode`, and `engineer`.\n\nMain Functionality:  \n- The `ExecuteWorkflow` class, specifically its `post` method, handles the execution of workflows, including SQL execution orders and data archiving orders. It begins by validating the input using a serializer (`ExecuteWorkflowSerializer`). Depending on the `workflow_type`, it performs different actions:\n  - For SQL execution orders (`workflow_type == 2`):\n    - It checks user permissions and whether the execution is allowed within a specified time frame.\n    - If the mode is \"auto\", it queues the workflow for automatic execution and logs the operation.\n    - If the mode is \"manual\", it marks the workflow as finished and logs the manual execution.\n    - It optionally sends notifications if configured to do so.\n  - For data archiving orders (`workflow_type == 3`), it asynchronously triggers the archiving process.\n\nOutputs / Return Values:  \n- The method returns an HTTP response. If the input validation fails, it returns a response with error details and a `400 BAD REQUEST` status. If the execution process starts successfully, it returns a response with a message indicating the execution has begun, advising users to check the workflow details page for results."
    },
    {
        "file_path": "sql_api\\api_workflow.py",
        "scope": "WorkflowLogList",
        "lineno": 418,
        "summarize": "User Input Sources:  \n- The class method `post` takes input from the user through `request.data`. This data is expected to contain fields such as `workflow_id` and `workflow_type`, which are used for querying the database.\n\nMain Functionality:  \n- The `WorkflowLogList` class is a Django REST framework API view designed to handle requests related to workflow logs. Its main purpose is to provide a paginated list of logs for a specific workflow. The class inherits from `generics.ListAPIView`, utilizing Django's generic views for handling list operations.\n- The `get` method is overridden to explicitly disallow GET requests, returning a message that the method is not allowed.\n- The `post` method is the primary functionality, where it validates the input data using `WorkflowLogSerializer`. If the data is valid, it retrieves the `audit_id` associated with the provided `workflow_id` and `workflow_type`. It then filters the logs based on this `audit_id`, orders them, paginates the results, and serializes the paginated data for the response.\n\nOutputs / Return Values:  \n- If a GET request is made, it returns a JSON response indicating that the GET method is not allowed.\n- For POST requests, if the input data is invalid, it returns a JSON response with error details and a status code of 400 (Bad Request).\n- If the input data is valid, it returns a paginated JSON response containing the serialized workflow logs associated with the specified workflow, using the `WorkflowLogListSerializer`."
    },
    {
        "file_path": "sql_api\\views.py",
        "scope": "info",
        "lineno": 24,
        "summarize": "User Input Sources:  \nThe function takes a parameter named `request`, which typically represents an HTTP request in a Django application. This implies that the function could be invoked in response to a web request, although the function does not directly use any specific data from the request object itself.\n\nMain Functionality:  \nThe function's core purpose is to gather version information from two components: `archery` and `django_q`. It constructs a dictionary named `system_info` that contains the version of the `archery` component and the version of the `django_q` component. The version of `django_q` is formatted as a string by joining its version tuple elements with periods.\n\nOutputs / Return Values:  \nThe function returns a `JsonResponse` object, which is a Django-specific response class that serializes the `system_info` dictionary into JSON format. This JSON object contains the version information of the `archery` and `django_q` components."
    },
    {
        "file_path": "sql_api\\views.py",
        "scope": "debug",
        "lineno": 38,
        "summarize": "User Input Sources:  \n- The function takes user input from the `request` object, specifically from the `GET` parameters. It retrieves the value of the `full` parameter, which determines whether to return full information or a summarized version for certain components.\n\nMain Functionality:  \n- The function is designed to gather and return comprehensive system diagnostics and configuration information. It collects data from various system components, including:\n  - System configuration settings via a `SysConfig` object.\n  - MySQL server information using a database cursor.\n  - Redis server information using a Redis connection.\n  - Django-Q task queue statistics, including broker and cluster statistics.\n  - GoInception and backup database connection details, including version and other configuration variables.\n  - Installed Python packages using `pkg_resources`.\n  - It also sanitizes certain sensitive configuration keys by replacing their values with asterisks.\n\nOutputs / Return Values:  \n- The function returns a JSON response containing a structured collection of system information. This includes:\n  - Archery version information.\n  - Django-Q statistics.\n  - GoInception information.\n  - Runtime information, such as Python version, MySQL and Redis information, system arguments, and platform details.\n  - Sanitized system configuration.\n  - A list of installed Python packages."
    },
    {
        "file_path": "sql_api\\views.py",
        "scope": "mirage",
        "lineno": 212,
        "summarize": "User Input Sources:  \nThe function `mirage` takes a single parameter, `request`, which is typically a Django HTTP request object. However, in this function, the `request` object is not directly used for processing or input extraction. The function operates on database instances and does not seem to take direct user input from the request.\n\nMain Functionality:  \nThe primary purpose of the `mirage` function is to migrate and re-encrypt certain fields of `Instance` data in a database. It specifically targets the `user` and `password` fields of the `Instance` model. The function first attempts to decrypt the `password` field of all `Instance` objects using a `Prpcrypt` object. If decryption is successful, the password is updated in the database. If decryption fails, the exception is caught, and the function proceeds without updating that specific entry. After attempting to decrypt all instances, it uses a `Migrator` object to re-encrypt the `user` and `password` fields with a new encryption mechanism provided by the `django-mirage-field` package.\n\nOutputs / Return Values:  \nThe function returns a JSON response. If the process is successful, it returns `{\"msg\": \"ok\"}`. If any exception occurs during execution, it returns a JSON response with the exception message, formatted as `{\"msg\": \"exception_message\"}`."
    }
]